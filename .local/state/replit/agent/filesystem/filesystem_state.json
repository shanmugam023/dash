{"file_contents":{"DEPLOYMENT_INSTRUCTIONS.md":{"content":"# Trading Dashboard Deployment Instructions\n\n## Quick Setup for Your System\n\n### Option 1: Automated Setup (Recommended)\n\n```bash\n# Download the project files to your server\n# Then run the quick start script:\nchmod +x quick_start.sh\n./quick_start.sh\n```\n\nThis will automatically:\n- Create virtual environment\n- Install dependencies  \n- Create configuration files\n- Give you options to run development, production, or setup as service\n\n### Option 2: Manual Setup\n\n### Prerequisites\n- Python 3.8+ installed\n- Git installed\n- PostgreSQL database (or use the provided PostgreSQL setup)\n\n### Step 1: Download and Setup\n\n```bash\n# Clone the repository\ngit clone <your-repository-url>\ncd trading-dashboard\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install flask flask-sqlalchemy gunicorn psycopg2-binary python-dotenv docker werkzeug\n```\n\n### Step 2: Database Setup\n\n#### Option A: Use PostgreSQL (Recommended)\n```bash\n# Install PostgreSQL if not installed\nsudo apt update\nsudo apt install postgresql postgresql-contrib\n\n# Create database and user\nsudo -u postgres psql\nCREATE DATABASE trading_dashboard;\nCREATE USER trading_user WITH PASSWORD 'your_password';\nGRANT ALL PRIVILEGES ON DATABASE trading_dashboard TO trading_user;\n\\q\n```\n\n#### Option B: Use Environment Database (Automatic)\nThe app will automatically create the database tables when you run it.\n\n### Step 3: Environment Configuration\n\nCreate a `.env` file in the project root:\n\n```bash\nDATABASE_URL=postgresql://trading_user:your_password@localhost/trading_dashboard\nSESSION_SECRET=your_secret_key_here_make_it_long_and_random\nFLASK_ENV=production\n```\n\n### Step 4: Run the Application\n\n#### Development Mode (Port 5000)\n```bash\npython main.py\n```\n\n#### Production Mode (Port 5000 - Default)\n```bash\npython start_server.py\n```\n\n#### Production Mode (Port 24242 - Ubuntu Server)\nEdit `gunicorn_config.py` and change:\n```python\nbind = \"0.0.0.0:24242\"\n```\n\nThen edit `start_server.py` and change all port references from 5000 to 24242.\n\nThen run:\n```bash\npython start_server.py\n```\n\n### Step 5: Access Your Dashboard\n\nOpen your web browser and go to:\n- Development: `http://localhost:5000`\n- Production: `http://localhost:5000` (or `http://localhost:24242` if configured)\n- Server: `http://your-server-ip:24242`\n\n## Features You'll See\n\n### Dashboard Overview\n✓ **Clean Phoenix-style Design** - Professional ecommerce-inspired interface\n✓ **Long vs Short Performance** - Focus on position types rather than users\n✓ **Real-time Trading Data** - Live P&L calculations and position tracking\n✓ **Interactive Charts** - Performance visualization with Chart.js\n✓ **Current Positions Table** - Active trades with real-time updates\n\n### Trading Analytics\n✓ **Period-based Filtering** - View data by Today, Week, Month, Year\n✓ **Performance Metrics** - Success rates, profit factors, win rates\n✓ **Position Breakdown** - Separate tracking for LONG and SHORT positions\n✓ **Bot Status Monitoring** - Trading bot health and activity status\n\n### Data Processing\n✓ **Automatic Log Parsing** - Processes your AVAUSDT and other trading logs\n✓ **Database Storage** - Complete trade history with PostgreSQL\n✓ **Real-time Updates** - Dashboard refreshes automatically\n\n## Ubuntu Server Deployment\n\n### For Port 24242 (Your Preference)\n\n1. **Install System Dependencies**\n```bash\nsudo apt update\nsudo apt install python3 python3-pip python3-venv postgresql postgresql-contrib nginx\n```\n\n2. **Setup Application**\n```bash\ngit clone <your-repo>\ncd trading-dashboard\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n```\n\n3. **Configure for Port 24242**\n```bash\n# Edit gunicorn_config.py\nnano gunicorn_config.py\n# Change: bind = \"0.0.0.0:24242\"\n\n# Edit start_server.py port references\nnano start_server.py\n# Change all 5000 references to 24242\n```\n\n4. **Setup as System Service (Automated)**\n```bash\nchmod +x setup_service.sh\n./setup_service.sh\n```\n\nThis will automatically:\n- Create the systemd service file\n- Configure environment variables\n- Enable the service\n- Provide management commands\n\n5. **Manual Service Management**\n```bash\n# Start the service\nsudo systemctl start trading-dashboard\n\n# Check status\nsudo systemctl status trading-dashboard\n\n# View logs\nsudo journalctl -u trading-dashboard -f\n\n# Stop the service\nsudo systemctl stop trading-dashboard\n\n# Restart the service  \nsudo systemctl restart trading-dashboard\n```\n\n6. **Configure Firewall**\n```bash\nsudo ufw allow 24242\nsudo ufw reload\n```\n\n### Access Your Dashboard\nYour dashboard will be available at: `http://your-server-ip:24242`\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Port Already in Use**\n```bash\nsudo lsof -i :24242\nsudo kill -9 <PID>\n```\n\n2. **Database Connection Error**\n- Check DATABASE_URL in .env file\n- Ensure PostgreSQL is running: `sudo systemctl status postgresql`\n- Test connection: `psql $DATABASE_URL`\n\n3. **Python Dependencies Missing**\n```bash\npip install -r requirements.txt\n```\n\n4. **Permission Denied**\n```bash\nchmod +x start_server.py\n```\n\n### Logs and Monitoring\n```bash\n# View application logs\njournalctl -u trading-dashboard -f\n\n# Check system resources\nhtop\n\n# Monitor network connections\nnetstat -tulpn | grep :24242\n```\n\n## Configuration Options\n\n### Environment Variables\n- `DATABASE_URL`: PostgreSQL connection string\n- `SESSION_SECRET`: Secret key for sessions\n- `FLASK_ENV`: development or production\n- `FLASK_DEBUG`: 1 for debug mode\n\n### Customization\n- **Port**: Edit `gunicorn_config.py` and `start_server.py`\n- **Workers**: Edit `gunicorn_config.py` workers setting\n- **Styling**: Modify `static/css/phoenix_dashboard.css`\n- **Features**: Update templates in `templates/` directory\n\n## Support\n\nIf you encounter any issues:\n1. Check the logs: `journalctl -u trading-dashboard -f`\n2. Verify all dependencies are installed\n3. Ensure PostgreSQL is running and accessible\n4. Check firewall settings for your chosen port\n\nYour trading dashboard is now ready with a professional Phoenix-style interface focusing on Long vs Short performance analysis!","size_bytes":6138},"README.md":{"content":"# Enhanced Trading Dashboard\n\nA comprehensive real-time trading dashboard for monitoring Binance trading bots with advanced analytics, trade history, and performance tracking.\n\n## Features\n\n### 🚀 Core Features\n- **Real-time Container Monitoring**: Track Docker containers running trading bots\n- **Comprehensive Trade Analytics**: Detailed statistics for multiple traders (Yuva & Shan)\n- **Enhanced Trade History**: Complete trade history with filtering by time periods\n- **Advanced Performance Metrics**: Win rates, profit factors, P&L analysis\n- **Professional Dashboard Design**: Modern, responsive UI with dark theme\n- **PostgreSQL Database**: Robust data storage with proper indexing\n\n### 📊 Analytics Features\n- **Period-based Analysis**: View stats by day, week, month, year, or all-time\n- **Long vs Short Comparison**: Separate tracking for LONG and SHORT positions\n- **Real-time P&L Calculation**: Live unrealized and realized P&L tracking\n- **Success/Failure Rates**: Detailed win/loss statistics\n- **Interactive Charts**: Performance comparison and distribution charts\n\n### 🔧 Technical Features\n- **Enhanced Log Parsing**: Advanced log processing from trading bot containers\n- **API Endpoints**: RESTful APIs for data access\n- **Auto-refresh**: Real-time data updates every 30 seconds\n- **Responsive Design**: Works on desktop, tablet, and mobile\n- **Production Ready**: Configured for Ubuntu server deployment\n\n## Installation & Setup\n\n### Prerequisites\n- Python 3.11+\n- PostgreSQL database\n- Docker (for container monitoring)\n- Ubuntu Server (recommended for production)\n\n### Quick Start\n\n1. **Clone and Setup**\n   ```bash\n   git clone <repository>\n   cd trading-dashboard\n   pip install -r requirements.txt\n   ```\n\n2. **Environment Variables**\n   ```bash\n   export DATABASE_URL=\"postgresql://user:pass@localhost/trading_db\"\n   export SESSION_SECRET=\"your-secret-key\"\n   ```\n\n3. **Start Development Server (Port 5000)**\n   ```bash\n   python start_server.py --dev\n   ```\n\n4. **Start Production Server**\n   ```bash\n   python start_server.py\n   ```\n\n### Ubuntu Server Deployment (Port 24242)\n\nFor Ubuntu server deployment on port 24242, modify the configuration files:\n- Update `gunicorn_config.py` bind setting to `\"0.0.0.0:24242\"`\n- Update `start_server.py` port references from 5000 to 24242\n- Then run the production server\n\n### Production Deployment on Ubuntu\n\n1. **Install Dependencies**\n   ```bash\n   sudo apt update\n   sudo apt install python3-pip python3-venv postgresql postgresql-contrib docker.io\n   ```\n\n2. **Setup Virtual Environment**\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate\n   pip install -r requirements.txt\n   ```\n\n3. **Configure Database**\n   ```bash\n   sudo -u postgres createdb trading_dashboard\n   sudo -u postgres createuser trading_user\n   ```\n\n4. **Start Production Server**\n   ```bash\n   python start_server.py\n   ```\n\nThe dashboard will be available at `http://your-server:24242`\n\n## API Endpoints\n\n### Core Endpoints\n- `GET /` - Main dashboard\n- `GET /api/container-status` - Container status information\n- `GET /api/trading-stats` - Trading statistics for both users\n- `GET /api/logs` - Recent log entries\n- `GET /api/refresh-data` - Refresh all data\n\n### Enhanced Endpoints\n- `GET /api/trade-history/<period>` - Trade history by period (today, week, month, year, all)\n- `GET /api/statistics/<user>/<period>` - User statistics by period\n- `GET /api/positions/current` - Current open positions\n\n## Configuration\n\n### Server Configuration\n- **Port**: 24242 (configurable in `gunicorn_config.py`)\n- **Workers**: 4 (configurable)\n- **Timeout**: 30 seconds\n- **Max Requests**: 1000 per worker\n\n### Database Schema\nThe dashboard uses PostgreSQL with the following main tables:\n- `trading_session` - Individual trades and positions\n- `trading_stats` - Aggregated statistics by user and period\n- `container_status` - Docker container monitoring data\n\n### Container Monitoring\nMonitors these Docker containers:\n- `Yuva_Positions_trading_bot` - Yuva's trading bot\n- `Shan_Positions_trading_bot` - Shan's trading bot\n- `log-reader` - Log processing container\n\n## Usage\n\n### Dashboard Features\n\n1. **Overview Cards**: Total trades, success/failure rates, and overall P&L\n2. **Time Period Filters**: Filter data by Today, This Week, This Month, This Year, or All Time\n3. **User Comparison**: Side-by-side comparison of Yuva and Shan performance\n4. **Current Positions**: Real-time view of open positions with live P&L\n5. **Trade History**: Complete trade history with filtering options\n6. **Performance Charts**: Visual comparison of trading performance\n7. **Container Status**: Real-time monitoring of trading bot containers\n\n### Key Metrics Tracked\n- **Total Trades**: Complete count of all trading sessions\n- **Success/Failure Rates**: Win/loss percentages\n- **Long vs Short Performance**: Separate tracking for position types\n- **Profit Factor**: Ratio of total profits to total losses\n- **Average Win/Loss**: Mean profit and loss amounts\n- **Win Rate**: Percentage of profitable trades\n- **Unrealized P&L**: Live profit/loss for open positions\n- **Realized P&L**: Profit/loss for closed positions\n\n## Log Processing\n\nThe dashboard automatically processes logs from trading bot containers to:\n- Extract position information (symbol, side, entry price, size)\n- Calculate real-time P&L\n- Track price movements\n- Monitor position status\n- Update trade statistics\n\n### Supported Log Formats\nThe log parser recognizes these patterns:\n- Position management: `📈 Managing LONG/SHORT position for SYMBOL:`\n- Entry prices: `Entry Price: X.XXXX`\n- Current prices: `Current Price: X.XXXX`\n- Position sizes: `Position Size: XXX.X`\n- Price movements: `Price Movement: X.XX%`\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Port 24242 in use**\n   ```bash\n   sudo lsof -i :24242\n   sudo kill -9 <PID>\n   ```\n\n2. **Database connection issues**\n   - Check DATABASE_URL environment variable\n   - Verify PostgreSQL is running\n   - Check database credentials\n\n3. **Docker connection issues**\n   - Ensure Docker daemon is running\n   - Check user permissions for Docker socket\n   - Verify container names match configuration\n\n4. **Missing dependencies**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n### Logs\nServer logs are written to stdout/stderr. For production deployment, consider using:\n- `systemd` for service management\n- `logrotate` for log rotation\n- `nginx` as reverse proxy\n\n## Development\n\n### Project Structure\n```\ntrading-dashboard/\n├── app.py                 # Flask application setup\n├── main.py               # Application entry point\n├── routes.py             # API routes and endpoints\n├── models.py             # Database models\n├── gunicorn_config.py    # Production server configuration\n├── start_server.py       # Server startup script\n├── services/             # Business logic services\n├── templates/            # Jinja2 templates\n├── static/              # CSS, JS, and assets\n└── README.md            # This file\n```\n\n### Adding New Features\n1. Update database models in `models.py`\n2. Add business logic in `services/`\n3. Create API endpoints in `routes.py`\n4. Update templates for UI changes\n5. Test with both development and production configurations\n\n## License\n\nThis project is proprietary software for trading bot monitoring and analytics.\n\n## Support\n\nFor issues and feature requests, please contact the development team.","size_bytes":7462},"app.py":{"content":"import os\nimport logging\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n# Set up logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"trading_dashboard_secret_key_2025\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# configure the database, relative to the app instance folder\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# initialize the app with the extension\ndb.init_app(app)\n\nwith app.app_context():\n    # Import models to ensure tables are created\n    import models\n    db.create_all()\n\n# Import routes\nfrom routes import *\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":1021},"gunicorn_config.py":{"content":"# Gunicorn configuration file for trading dashboard\nimport os\n\n# Server socket\nbind = \"0.0.0.0:5000\"\nbacklog = 2048\n\n# Worker processes\nworkers = 4\nworker_class = \"sync\"\nworker_connections = 1000\ntimeout = 30\nkeepalive = 2\nmax_requests = 1000\nmax_requests_jitter = 100\n\n# Restart workers after this many requests, with up to 100 random seconds\n# This helps prevent memory leaks\npreload_app = True\n\n# Security\nlimit_request_line = 4094\nlimit_request_fields = 100\nlimit_request_field_size = 8190\n\n# Logging\naccesslog = \"-\"\nerrorlog = \"-\"\nloglevel = \"info\"\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\" %(D)s'\n\n# Process naming\nproc_name = \"trading_dashboard\"\n\n# Development vs Production\ndebug = os.getenv(\"FLASK_ENV\") == \"development\"\nreload = debug\n\ndef when_ready(server):\n    server.log.info(\"Trading Dashboard is ready to serve requests on port 24242\")\n\ndef worker_int(worker):\n    worker.log.info(\"Worker received INT or QUIT signal\")\n\ndef pre_fork(server, worker):\n    server.log.info(\"Worker spawned (pid: %s)\", worker.pid)","size_bytes":1064},"main.py":{"content":"from app import app\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":99},"models.py":{"content":"from app import db\nfrom datetime import datetime\nfrom sqlalchemy import Integer, String, Float, DateTime, Boolean, Text, Index\n\nclass TradingSession(db.Model):\n    id = db.Column(Integer, primary_key=True)\n    user = db.Column(String(50), nullable=False)  # 'Yuva' or 'Shan'\n    symbol = db.Column(String(20), nullable=False)\n    side = db.Column(String(10), nullable=False)  # 'LONG' or 'SHORT'\n    entry_price = db.Column(Float, nullable=False)\n    exit_price = db.Column(Float)\n    position_size = db.Column(Float, nullable=False)\n    pnl = db.Column(Float, default=0.0)\n    realized_pnl = db.Column(Float, default=0.0)\n    unrealized_pnl = db.Column(Float, default=0.0)\n    status = db.Column(String(20), default='OPEN')  # 'OPEN', 'CLOSED', 'STOPPED'\n    trade_type = db.Column(String(20), default='MANUAL')  # 'MANUAL', 'AUTO', 'STOP_LOSS', 'TAKE_PROFIT'\n    strategy = db.Column(String(100))\n    notes = db.Column(Text)\n    created_at = db.Column(DateTime, default=datetime.utcnow)\n    closed_at = db.Column(DateTime)\n    \n    # Add indexes for better query performance\n    __table_args__ = (\n        Index('idx_user_created', 'user', 'created_at'),\n        Index('idx_symbol_status', 'symbol', 'status'),\n        Index('idx_user_side', 'user', 'side'),\n    )\n\nclass ContainerStatus(db.Model):\n    id = db.Column(Integer, primary_key=True)\n    container_name = db.Column(String(100), nullable=False, unique=True)\n    status = db.Column(String(20), nullable=False)\n    last_updated = db.Column(DateTime, default=datetime.utcnow)\n    uptime = db.Column(String(50))\n\nclass TradingStats(db.Model):\n    id = db.Column(Integer, primary_key=True)\n    user = db.Column(String(50), nullable=False)\n    period = db.Column(String(20), nullable=False)  # 'daily', 'weekly', 'monthly', 'yearly'\n    period_date = db.Column(DateTime, nullable=False)  # Start date of the period\n    total_trades = db.Column(Integer, default=0)\n    successful_trades = db.Column(Integer, default=0)\n    failed_trades = db.Column(Integer, default=0)\n    long_trades = db.Column(Integer, default=0)\n    short_trades = db.Column(Integer, default=0)\n    long_successful = db.Column(Integer, default=0)\n    long_failed = db.Column(Integer, default=0)\n    short_successful = db.Column(Integer, default=0)\n    short_failed = db.Column(Integer, default=0)\n    total_pnl = db.Column(Float, default=0.0)\n    total_volume = db.Column(Float, default=0.0)\n    win_rate = db.Column(Float, default=0.0)\n    profit_factor = db.Column(Float, default=0.0)\n    avg_win = db.Column(Float, default=0.0)\n    avg_loss = db.Column(Float, default=0.0)\n    max_drawdown = db.Column(Float, default=0.0)\n    last_updated = db.Column(DateTime, default=datetime.utcnow)\n    \n    __table_args__ = (\n        Index('idx_user_period', 'user', 'period', 'period_date'),\n    )\n","size_bytes":2816},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"docker>=7.1.0\",\n    \"email-validator>=2.2.0\",\n    \"flask>=3.1.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-dotenv>=1.1.1\",\n    \"sqlalchemy>=2.0.42\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":378},"quick_start.sh":{"content":"#!/bin/bash\n\n# Quick Start Script for Trading Dashboard\n# Run this script to quickly set up and start the dashboard\n\necho \"🚀 Trading Dashboard Quick Start\"\necho \"=================================\"\n\n# Check if Python is installed\nif ! command -v python3 &> /dev/null; then\n    echo \"❌ Python 3 is not installed. Please install Python 3.8+ first.\"\n    exit 1\nfi\n\n# Check if pip is installed\nif ! command -v pip3 &> /dev/null; then\n    echo \"❌ pip3 is not installed. Please install pip3 first.\"\n    exit 1\nfi\n\n# Create virtual environment if it doesn't exist\nif [ ! -d \"venv\" ]; then\n    echo \"📦 Creating virtual environment...\"\n    python3 -m venv venv\nfi\n\n# Activate virtual environment\necho \"🔧 Activating virtual environment...\"\nsource venv/bin/activate\n\n# Install dependencies\necho \"📥 Installing dependencies...\"\npip install --upgrade pip\npip install flask flask-sqlalchemy gunicorn psycopg2-binary python-dotenv docker werkzeug\n\n# Create .env file if it doesn't exist\nif [ ! -f \".env\" ]; then\n    echo \"📝 Creating .env file...\"\n    cat > .env << EOF\n# Database Configuration\nDATABASE_URL=postgresql://trading_user:your_password@localhost/trading_dashboard\n\n# Security\nSESSION_SECRET=your_secret_key_here_make_it_long_and_random\n\n# Application\nFLASK_ENV=production\nFLASK_DEBUG=0\nEOF\n    echo \"⚠️  Please edit .env file with your actual database credentials!\"\nfi\n\n# Check if PostgreSQL is running\nif systemctl is-active --quiet postgresql; then\n    echo \"✅ PostgreSQL is running\"\nelse\n    echo \"⚠️  PostgreSQL is not running. Starting it now...\"\n    sudo systemctl start postgresql\nfi\n\necho \"\"\necho \"🎯 Choose how to run the dashboard:\"\necho \"1. Development mode (with auto-reload)\"\necho \"2. Production mode (with gunicorn)\"\necho \"3. Setup as system service\"\necho \"\"\nread -p \"Enter your choice (1-3): \" choice\n\ncase $choice in\n    1)\n        echo \"🚀 Starting in development mode...\"\n        python main.py\n        ;;\n    2)\n        echo \"🚀 Starting in production mode...\"\n        python start_server.py\n        ;;\n    3)\n        echo \"🔧 Setting up as system service...\"\n        chmod +x setup_service.sh\n        ./setup_service.sh\n        echo \"\"\n        read -p \"Do you want to start the service now? (y/n): \" start_service\n        if [ \"$start_service\" = \"y\" ] || [ \"$start_service\" = \"Y\" ]; then\n            sudo systemctl start trading-dashboard\n            echo \"✅ Service started! Check status with: sudo systemctl status trading-dashboard\"\n        fi\n        ;;\n    *)\n        echo \"❌ Invalid choice. Exiting.\"\n        exit 1\n        ;;\nesac\n\necho \"\"\necho \"🌐 Dashboard will be available at:\"\necho \"   http://localhost:24242\"\necho \"\"\necho \"📊 Features:\"\necho \"   ✓ Phoenix-style professional interface\"\necho \"   ✓ Long vs Short position comparison\"  \necho \"   ✓ Real-time trading data\"\necho \"   ✓ Performance analytics\"\necho \"   ✓ Bot status monitoring\"","size_bytes":2918},"replit.md":{"content":"# Enhanced Trading Dashboard\n\n## Overview\n\nThis is a comprehensive real-time trading dashboard built with Flask that monitors Docker containers running Binance trading bots for two users (Yuva and Shan). The enhanced system includes advanced trade history storage, period-based analytics (daily, weekly, monthly, yearly), professional UI design, and runs on port 24242 for Ubuntu server deployment. The dashboard provides detailed performance comparisons, interactive charts, comprehensive trade filtering, and real-time P&L calculations with PostgreSQL database storage.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\nPreferred deployment: Replit environment on port 5000 (migrated from Ubuntu server deployment)\nMigration status: Successfully migrated from Replit Agent to Replit environment with PostgreSQL database\nDesign preference: Clean, professional Phoenix-style light theme dashboard focusing exclusively on Long vs Short comparison\nData requirements: Complete trade history storage with period-based comparisons (today, yesterday, week, month, year, all-time)\nAnalytics focus: Long vs Short position performance analysis with historical trends\n\n## System Architecture\n\n### Backend Architecture\n- **Flask Web Framework**: Core web application using Flask with SQLAlchemy ORM for PostgreSQL database operations\n- **Enhanced Service Layer**: Advanced services for Docker monitoring, enhanced log parsing, and comprehensive trading analytics\n- **Enhanced Database Models**: Extended SQLAlchemy models with trade history, period-based statistics, and performance indexing\n- **Extended RESTful API**: JSON endpoints for real-time data, period-based filtering, and trade history access\n- **Production Configuration**: Gunicorn server setup with multi-worker configuration for Ubuntu deployment\n\n### Frontend Architecture\n- **Bootstrap 5 UI**: Modern responsive design with dark theme optimized for trading environments\n- **Real-time Updates**: JavaScript-based auto-refresh functionality with 30-second intervals\n- **Interactive Charts**: Chart.js integration for visualizing trading performance and metrics\n- **Component-based Templates**: Jinja2 templating with base template inheritance\n\n### Data Storage\n- **PostgreSQL Database**: Production-ready database with connection pooling and automatic schema creation\n- **Enhanced Trading Session Tracking**: Extended position tracking with realized/unrealized P&L, trade types, and strategy notes\n- **Period-based Statistics**: Daily, weekly, monthly, and yearly aggregated statistics with separate long/short tracking\n- **Trade History Storage**: Complete historical data with advanced filtering and period-based comparisons\n- **Performance Analytics**: Advanced statistical calculations including profit factors, win rates, and detailed breakdowns\n\n### Docker Integration\n- **Container Monitoring**: Direct Docker API integration to monitor three specific containers (Yuva_Positions_trading_bot, Shan_Positions_trading_bot, log-reader)\n- **Log Processing**: Real-time parsing of trading bot logs to extract position data and trading signals\n- **Health Checks**: Automatic container status updates with uptime calculations\n\n### Enhanced Trading Analytics Engine\n- **Historical Analytics Service**: Comprehensive trade history analysis with Long vs Short comparisons\n- **Period-based Comparisons**: Complete analytics for today, yesterday, week, month, year, and all-time periods\n- **Real-time Position Management**: Live tracking of LONG/SHORT positions with unrealized P&L calculations\n- **Performance Metrics**: Success rates, profit factors, win rates, and trend analysis by position type\n- **Weekly/Monthly Trends**: Historical comparison charts showing Long vs Short performance over time\n- **Automated Data Storage**: Daily statistics saved automatically for long-term trend analysis\n- **Interactive Visualizations**: Professional charts for performance comparison and trading distribution analysis\n\n## External Dependencies\n\n### Core Framework Dependencies\n- **Flask**: Web framework with SQLAlchemy database integration\n- **Docker Python SDK**: Container monitoring and status checking\n- **SQLAlchemy**: Database ORM with declarative base models\n\n### Frontend Libraries\n- **Bootstrap 5**: CSS framework for responsive UI components\n- **Font Awesome 6**: Icon library for dashboard visual elements\n- **Chart.js**: JavaScript charting library for performance visualization\n\n### Trading Platform Integration\n- **Binance API**: Indirect integration through containerized trading bots for position and order data\n- **Log File Monitoring**: File-based log parsing from trading bot containers\n\n### Production Infrastructure\n- **PostgreSQL**: Production database with comprehensive trade history storage and indexing\n- **Docker Engine**: Container runtime for trading bot management and log processing\n- **Gunicorn WSGI Server**: Multi-worker production server configuration on port 24242 ONLY\n- **Ubuntu Server Deployment**: Complete systemd service integration with automated setup scripts\n- **ProxyFix Middleware**: Production deployment support with reverse proxy handling\n- **Enhanced Log Processing**: Advanced log parsing from trading bot containers with real-time updates\n- **Automated Service Management**: Quick start scripts and service configuration for easy deployment\n- **Historical Data Pipeline**: Automated daily statistics collection and trend analysis","size_bytes":5456},"routes.py":{"content":"from flask import render_template, jsonify, request\nfrom app import app, db\nfrom models import TradingSession, ContainerStatus, TradingStats\nfrom services.docker_monitor import DockerMonitor\nfrom services.enhanced_log_parser import EnhancedLogParser\nfrom services.trading_analytics import TradingAnalytics\nfrom services.historical_analytics import historical_analytics\nfrom services.log_reader_service import LogReaderService\nimport logging\n\n# Initialize services\ndocker_monitor = DockerMonitor()\nlog_parser = EnhancedLogParser()\ntrading_analytics = TradingAnalytics()\nlog_reader_service = LogReaderService()\n\n@app.route('/')\ndef dashboard():\n    \"\"\"Enhanced dashboard route\"\"\"\n    try:\n        # Get container statuses\n        containers = docker_monitor.get_container_status()\n        \n        # Get trading statistics\n        yuva_stats = trading_analytics.get_user_stats('Yuva')\n        shan_stats = trading_analytics.get_user_stats('Shan')\n        \n        # Get recent trading sessions (increased limit)\n        recent_trades = TradingSession.query.order_by(TradingSession.created_at.desc()).limit(50).all()\n        \n        # Get current positions\n        current_positions = trading_analytics.get_current_positions()\n        \n        # Parse latest logs for real-time data\n        log_parser.parse_latest_logs()\n        \n        # Get trading summary from log-reader\n        trading_summary = log_reader_service.get_trading_summary()\n        \n        return render_template('phoenix_dashboard.html',\n                             containers=containers,\n                             yuva_stats=yuva_stats,\n                             shan_stats=shan_stats,\n                             recent_trades=recent_trades,\n                             current_positions=current_positions,\n                             trading_summary=trading_summary)\n    except Exception as e:\n        logging.error(f\"Dashboard error: {e}\")\n        return render_template('phoenix_dashboard.html',\n                             containers=[],\n                             yuva_stats={},\n                             shan_stats={},\n                             recent_trades=[],\n                             current_positions=[],\n                             trading_summary={})\n\n@app.route('/api/container-status')\ndef api_container_status():\n    \"\"\"API endpoint for container status\"\"\"\n    try:\n        containers = docker_monitor.get_container_status()\n        return jsonify(containers)\n    except Exception as e:\n        logging.error(f\"Container status API error: {e}\")\n        return jsonify([])\n\n@app.route('/api/trading-stats')\ndef api_trading_stats():\n    \"\"\"API endpoint for trading statistics\"\"\"\n    try:\n        yuva_stats = trading_analytics.get_user_stats('Yuva')\n        shan_stats = trading_analytics.get_user_stats('Shan')\n        \n        return jsonify({\n            'yuva': yuva_stats,\n            'shan': shan_stats\n        })\n    except Exception as e:\n        logging.error(f\"Trading stats API error: {e}\")\n        return jsonify({'yuva': {}, 'shan': {}})\n\n@app.route('/api/logs')\ndef api_logs():\n    \"\"\"API endpoint for recent logs\"\"\"\n    try:\n        logs = log_parser.get_recent_logs(limit=50)\n        return jsonify(logs)\n    except Exception as e:\n        logging.error(f\"Logs API error: {e}\")\n        return jsonify([])\n\n@app.route('/api/trade-history/<period>')\ndef api_trade_history(period):\n    \"\"\"API endpoint for trade history by period\"\"\"\n    try:\n        trades = trading_analytics.get_trade_history_by_period(period)\n        return jsonify(trades)\n    except Exception as e:\n        logging.error(f\"Trade history API error: {e}\")\n        return jsonify([])\n\n@app.route('/api/statistics/<user>/<period>')\ndef api_user_statistics(user, period):\n    \"\"\"API endpoint for user statistics by period\"\"\"\n    try:\n        stats = trading_analytics.get_user_stats_by_period(user, period)\n        return jsonify(stats)\n    except Exception as e:\n        logging.error(f\"User statistics API error: {e}\")\n        return jsonify({})\n\n@app.route('/api/refresh-data')\ndef api_refresh_data():\n    \"\"\"Refresh all data\"\"\"\n    try:\n        # Update container statuses\n        docker_monitor.update_container_status()\n        \n        # Parse latest logs\n        log_parser.parse_latest_logs()\n        \n        # Recalculate analytics\n        trading_analytics.update_statistics()\n        \n        return jsonify({'status': 'success'})\n    except Exception as e:\n        logging.error(f\"Refresh data error: {e}\")\n        return jsonify({'status': 'error', 'message': str(e)})\n\n@app.route('/api/log-reader')\ndef api_log_reader():\n    \"\"\"API endpoint for log-reader container logs\"\"\"\n    try:\n        lines = request.args.get('lines', 100, type=int)\n        logs = log_reader_service.get_log_reader_logs(lines=lines)\n        return jsonify(logs)\n    except Exception as e:\n        logging.error(f\"Log reader API error: {e}\")\n        return jsonify([])\n\n@app.route('/api/trading-summary')\ndef api_trading_summary():\n    \"\"\"API endpoint for trading summary from log-reader\"\"\"\n    try:\n        summary = log_reader_service.get_trading_summary()\n        return jsonify(summary)\n    except Exception as e:\n        logging.error(f\"Trading summary API error: {e}\")\n        return jsonify({})\n\n@app.route('/logs')\ndef logs_viewer():\n    \"\"\"Dedicated logs viewer page\"\"\"\n    try:\n        # Get log reader logs\n        logs = log_reader_service.get_log_reader_logs(lines=200)\n        trading_summary = log_reader_service.get_trading_summary()\n        \n        return render_template('logs_viewer.html',\n                             logs=logs,\n                             trading_summary=trading_summary)\n    except Exception as e:\n        logging.error(f\"Logs viewer error: {e}\")\n        return render_template('logs_viewer.html',\n                             logs=[],\n                             trading_summary={})\n","size_bytes":5905},"setup_service.sh":{"content":"#!/bin/bash\n\n# Trading Dashboard Service Setup Script\n# This script sets up the trading dashboard as a systemd service\n\necho \"🚀 Setting up Trading Dashboard Service...\"\n\n# Get current directory\nCURRENT_DIR=$(pwd)\nUSER=$(whoami)\n\n# Check if we're in the right directory\nif [ ! -f \"main.py\" ]; then\n    echo \"❌ Error: Please run this script from the trading dashboard directory\"\n    exit 1\nfi\n\n# Create systemd service file\necho \"📝 Creating systemd service file...\"\nsudo tee /etc/systemd/system/trading-dashboard.service > /dev/null <<EOF\n[Unit]\nDescription=Trading Dashboard - Binance Trading Analytics\nAfter=network.target postgresql.service\nWants=postgresql.service\n\n[Service]\nType=exec\nUser=$USER\nGroup=$USER\nWorkingDirectory=$CURRENT_DIR\nEnvironment=PATH=$CURRENT_DIR/venv/bin\nEnvironment=DATABASE_URL=postgresql://trading_user:Redshan%40123@localhost/trading_dashboard\nEnvironment=SESSION_SECRET=your_secret_key_here_make_it_long_and_random\nEnvironment=FLASK_ENV=production\nExecStart=$CURRENT_DIR/venv/bin/python start_server.py\nRestart=always\nRestartSec=3\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\necho \"✅ Service file created at /etc/systemd/system/trading-dashboard.service\"\n\n# Reload systemd\necho \"🔄 Reloading systemd daemon...\"\nsudo systemctl daemon-reload\n\n# Enable the service\necho \"🔧 Enabling trading dashboard service...\"\nsudo systemctl enable trading-dashboard\n\necho \"✅ Trading Dashboard service setup complete!\"\necho \"\"\necho \"📋 Available commands:\"\necho \"  Start service:    sudo systemctl start trading-dashboard\"\necho \"  Stop service:     sudo systemctl stop trading-dashboard\"\necho \"  Restart service:  sudo systemctl restart trading-dashboard\"\necho \"  Check status:     sudo systemctl status trading-dashboard\"\necho \"  View logs:        sudo journalctl -u trading-dashboard -f\"\necho \"\"\necho \"🌐 After starting, your dashboard will be available at:\"\necho \"  http://localhost:24242\"\necho \"\"\necho \"⚠️  Remember to:\"\necho \"  1. Update the DATABASE_URL in the service file with your actual database credentials\"\necho \"  2. Update the SESSION_SECRET with a secure random string\"\necho \"  3. Ensure PostgreSQL is running: sudo systemctl start postgresql\"\necho \"  4. Configure firewall if needed: sudo ufw allow 24242\"\n","size_bytes":2302},"start_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTrading Dashboard Server Startup Script\nThis script starts the trading dashboard on port 24242 for Ubuntu server deployment\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport signal\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\ndef check_dependencies():\n    \"\"\"Check if all required packages are installed\"\"\"\n    try:\n        import flask\n        import gunicorn\n        import psycopg2\n        import docker\n        logger.info(\"All dependencies are available\")\n        return True\n    except ImportError as e:\n        logger.error(f\"Missing dependency: {e}\")\n        return False\n\ndef check_database():\n    \"\"\"Check database connectivity\"\"\"\n    try:\n        from app import db, app\n        with app.app_context():\n            db.create_all()\n        logger.info(\"Database connection successful\")\n        return True\n    except Exception as e:\n        logger.error(f\"Database connection failed: {e}\")\n        return False\n\ndef check_port(port=24242):\n    \"\"\"Check if port is available\"\"\"\n    import socket\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        try:\n            s.bind(('0.0.0.0', port))\n            logger.info(f\"Port {port} is available\")\n            return True\n        except OSError:\n            logger.error(f\"Port {port} is already in use\")\n            return False\n\ndef start_production_server():\n    \"\"\"Start the production server using gunicorn\"\"\"\n    logger.info(\"Starting Trading Dashboard in production mode on port 24242...\")\n    \n    # Check all prerequisites\n    if not check_dependencies():\n        logger.error(\"Cannot start server: missing dependencies\")\n        sys.exit(1)\n    \n    if not check_database():\n        logger.error(\"Cannot start server: database connection failed\")\n        sys.exit(1)\n    \n    if not check_port():\n        logger.error(\"Cannot start server: port 24242 is in use\")\n        sys.exit(1)\n    \n    # Set environment variables\n    os.environ['FLASK_ENV'] = 'production'\n    os.environ['PYTHONPATH'] = str(Path.cwd())\n    \n    # Gunicorn command\n    cmd = [\n        'gunicorn',\n        '--config', 'gunicorn_config.py',\n        '--bind', '0.0.0.0:24242',\n        '--workers', '4',\n        '--worker-class', 'sync',\n        '--timeout', '30',\n        '--keepalive', '2',\n        '--max-requests', '1000',\n        '--max-requests-jitter', '100',\n        '--preload',\n        '--access-logfile', '-',\n        '--error-logfile', '-',\n        '--log-level', 'info',\n        'main:app'\n    ]\n    \n    try:\n        # Start the server\n        logger.info(\"Executing: \" + ' '.join(cmd))\n        process = subprocess.Popen(cmd)\n        \n        # Handle shutdown gracefully\n        def signal_handler(signum, frame):\n            logger.info(\"Received shutdown signal, stopping server...\")\n            process.terminate()\n            process.wait()\n            logger.info(\"Server stopped\")\n            sys.exit(0)\n        \n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n        \n        logger.info(\"Trading Dashboard is running on http://0.0.0.0:24242\")\n        logger.info(\"Press Ctrl+C to stop the server\")\n        \n        # Wait for the process to complete\n        process.wait()\n        \n    except Exception as e:\n        logger.error(f\"Failed to start server: {e}\")\n        sys.exit(1)\n\ndef start_development_server():\n    \"\"\"Start the development server\"\"\"\n    logger.info(\"Starting Trading Dashboard in development mode on port 24242...\")\n    \n    if not check_dependencies():\n        logger.error(\"Cannot start server: missing dependencies\")\n        sys.exit(1)\n    \n    if not check_database():\n        logger.error(\"Cannot start server: database connection failed\")\n        sys.exit(1)\n    \n    os.environ['FLASK_ENV'] = 'development'\n    os.environ['FLASK_DEBUG'] = '1'\n    \n    try:\n        from main import app\n        app.run(host='0.0.0.0', port=24242, debug=True)\n    except Exception as e:\n        logger.error(f\"Failed to start development server: {e}\")\n        sys.exit(1)\n\nif __name__ == '__main__':\n    # Check command line arguments\n    if len(sys.argv) > 1 and sys.argv[1] == '--dev':\n        start_development_server()\n    else:\n        start_production_server()","size_bytes":4412},"services/docker_monitor.py":{"content":"import docker\nimport logging\nfrom datetime import datetime\nfrom app import db\nfrom models import ContainerStatus\n\nclass DockerMonitor:\n    def __init__(self):\n        try:\n            self.client = docker.from_env()\n        except Exception as e:\n            logging.error(f\"Failed to connect to Docker: {e}\")\n            self.client = None\n\n    def get_container_status(self):\n        \"\"\"Get status of trading bot containers\"\"\"\n        containers_info = []\n        \n        if not self.client:\n            return containers_info\n        \n        target_containers = [\n            'Yuva_Positions_trading_bot',\n            'Shan_Positions_trading_bot',\n            'log-reader'\n        ]\n        \n        try:\n            containers = self.client.containers.list(all=True)\n            \n            for container in containers:\n                container_name = container.name\n                if container_name in target_containers:\n                    status_info = {\n                        'name': container_name,\n                        'status': container.status,\n                        'id': container.short_id,\n                        'image': container.image.tags[0] if container.image.tags else 'unknown',\n                        'created': container.attrs['Created'],\n                        'uptime': self._calculate_uptime(container)\n                    }\n                    containers_info.append(status_info)\n                    \n                    # Update database\n                    self._update_container_status(container_name, container.status, status_info['uptime'])\n            \n            # Add missing containers as offline\n            found_names = [c['name'] for c in containers_info]\n            for target in target_containers:\n                if target not in found_names:\n                    containers_info.append({\n                        'name': target,\n                        'status': 'not_found',\n                        'id': 'N/A',\n                        'image': 'N/A',\n                        'created': 'N/A',\n                        'uptime': 'N/A'\n                    })\n                    self._update_container_status(target, 'not_found', 'N/A')\n                    \n        except Exception as e:\n            logging.error(f\"Error getting container status: {e}\")\n        \n        return containers_info\n\n    def _calculate_uptime(self, container):\n        \"\"\"Calculate container uptime\"\"\"\n        try:\n            if container.status != 'running':\n                return 'Not running'\n            \n            started_at = container.attrs['State']['StartedAt']\n            started_time = datetime.fromisoformat(started_at.replace('Z', '+00:00'))\n            uptime = datetime.now(started_time.tzinfo) - started_time\n            \n            days = uptime.days\n            hours, remainder = divmod(uptime.seconds, 3600)\n            minutes, _ = divmod(remainder, 60)\n            \n            if days > 0:\n                return f\"{days}d {hours}h {minutes}m\"\n            elif hours > 0:\n                return f\"{hours}h {minutes}m\"\n            else:\n                return f\"{minutes}m\"\n                \n        except Exception as e:\n            logging.error(f\"Error calculating uptime: {e}\")\n            return \"Unknown\"\n\n    def _update_container_status(self, name, status, uptime):\n        \"\"\"Update container status in database\"\"\"\n        try:\n            container_status = ContainerStatus.query.filter_by(container_name=name).first()\n            if container_status:\n                container_status.status = status\n                container_status.uptime = uptime\n                container_status.last_updated = datetime.utcnow()\n            else:\n                container_status = ContainerStatus(\n                    container_name=name,\n                    status=status,\n                    uptime=uptime\n                )\n                db.session.add(container_status)\n            \n            db.session.commit()\n        except Exception as e:\n            logging.error(f\"Error updating container status: {e}\")\n            db.session.rollback()\n\n    def update_container_status(self):\n        \"\"\"Update all container statuses\"\"\"\n        return self.get_container_status()\n","size_bytes":4242},"services/enhanced_log_parser.py":{"content":"import re\nimport logging\nimport os\nfrom datetime import datetime\nfrom app import db\nfrom models import TradingSession\n\nclass EnhancedLogParser:\n    def __init__(self):\n        self.log_patterns = {\n            'position_entry': r'📈 Managing (LONG|SHORT) position for ([A-Z]+USDT):',\n            'position_size': r'Position Size: ([\\d.]+)',\n            'entry_price': r'Entry Price: ([\\d.]+)',\n            'current_price': r'Current Price: ([\\d.]+)',\n            'price_movement': r'Price Movement: ([\\d.-]+)%',\n            'success_count': r'(BUY|SELL) Success Count: (\\d+)',\n            'stop_loss_count': r'(BUY|SELL) Stop Loss Count: (\\d+)',\n            'live_trade_success': r'Live Trade Success Count: (\\d+)',\n            'live_trade_failure': r'Live Trade Failure Count: (\\d+)',\n            'container_status': r'(BUY|SELL) Container Running: (True|False)',\n            'new_position': r'🆕 New position detected - Original size: ([\\d.]+)',\n            'full_position': r'📊 Full position still active',\n            'orders_set': r'✅ Orders already correctly set for ([A-Z]+USDT)',\n            'checking_positions': r'🔄 Checking dynamic positions and orders',\n            'fetching_positions': r'Fetching all open positions',\n            'sleeping': r'⏰ Sleeping for (\\d+) minute',\n            'starting_bot': r'🚀 Starting Binance Futures Trading Bot',\n            'strategy_info': r'📋 Strategy: (.+)',\n        }\n        \n        # Container name to user mapping\n        self.container_user_map = {\n            'Yuva_Positions_trading_bot': 'Yuva',\n            'Shan_Positions_trading_bot': 'Shan'\n        }\n\n    def parse_container_logs(self, container_name):\n        \"\"\"Parse logs from a specific container\"\"\"\n        try:\n            import docker\n            client = docker.from_env()\n            container = client.containers.get(container_name)\n            \n            # Get last 100 lines of logs\n            logs = container.logs(tail=100, timestamps=True).decode('utf-8')\n            \n            user = self.container_user_map.get(container_name, 'Unknown')\n            self._parse_log_content(logs, user)\n            \n        except Exception as e:\n            logging.error(f\"Error parsing container logs for {container_name}: {e}\")\n\n    def parse_latest_logs(self):\n        \"\"\"Parse latest logs from all containers\"\"\"\n        try:\n            # Parse logs from both trading containers\n            for container_name in self.container_user_map.keys():\n                self.parse_container_logs(container_name)\n                \n            # Also parse sample data for demonstration\n            self._parse_sample_logs()\n            \n        except Exception as e:\n            logging.error(f\"Error parsing latest logs: {e}\")\n\n    def _parse_log_content(self, log_content, user):\n        \"\"\"Parse log content and extract trading information\"\"\"\n        lines = log_content.split('\\n')\n        \n        current_symbol = None\n        current_side = None\n        current_data = {}\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            # Extract timestamp if present\n            timestamp_match = re.match(r'^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z)', line)\n            if timestamp_match:\n                line = line[len(timestamp_match.group(1)):].strip()\n            \n            # Check for position entry\n            position_match = re.search(self.log_patterns['position_entry'], line)\n            if position_match:\n                # Save previous position if exists\n                if current_symbol and current_data:\n                    self._save_position(current_symbol, current_side, current_data, user)\n                \n                current_side = position_match.group(1)\n                current_symbol = position_match.group(2)\n                current_data = {'timestamp': datetime.utcnow()}\n                continue\n            \n            # Parse position details\n            if current_symbol:\n                size_match = re.search(self.log_patterns['position_size'], line)\n                if size_match:\n                    current_data['size'] = float(size_match.group(1))\n                    continue\n                \n                entry_match = re.search(self.log_patterns['entry_price'], line)\n                if entry_match:\n                    current_data['entry_price'] = float(entry_match.group(1))\n                    continue\n                \n                current_match = re.search(self.log_patterns['current_price'], line)\n                if current_match:\n                    current_data['current_price'] = float(current_match.group(1))\n                    continue\n                \n                movement_match = re.search(self.log_patterns['price_movement'], line)\n                if movement_match:\n                    current_data['price_movement'] = float(movement_match.group(1))\n                    continue\n                \n                # Check for new position marker\n                if re.search(self.log_patterns['new_position'], line):\n                    current_data['is_new'] = True\n                    continue\n        \n        # Save the last position\n        if current_symbol and current_data:\n            self._save_position(current_symbol, current_side, current_data, user)\n\n    def _parse_sample_logs(self):\n        \"\"\"Parse sample log data for demonstration\"\"\"\n        sample_logs = [\n            \"📈 Managing LONG position for AVAUSDT:\",\n            \"Position Size: 268.5\",\n            \"Entry Price: 0.5615128119181\",\n            \"Current Price: 0.5585000\",\n            \"Price Movement: 0.54%\",\n            \"📈 Managing LONG position for STEEMUSDT:\",\n            \"Position Size: 1127\",\n            \"Entry Price: 0.1343161047028\",\n            \"Current Price: 0.134300\",\n            \"Price Movement: 0.01%\",\n            \"📈 Managing LONG position for CHRUSDT:\",\n            \"Position Size: 1755\",\n            \"Entry Price: 0.0901\",\n            \"Current Price: 0.0890\",\n            \"Price Movement: 1.22%\",\n            \"📈 Managing LONG position for GHSTUSDT:\",\n            \"Position Size: 365\", \n            \"Entry Price: 0.4330567123287\",\n            \"Current Price: 0.4308000\",\n            \"Price Movement: 0.52%\"\n        ]\n        \n        try:\n            current_symbol = None\n            current_side = None\n            current_data = {}\n            \n            for log_line in sample_logs:\n                # Check for position entry\n                position_match = re.search(self.log_patterns['position_entry'], log_line)\n                if position_match:\n                    if current_symbol and current_data:\n                        # Alternate between Yuva and Shan for demo\n                        user = 'Yuva' if current_symbol in ['AVAUSDT', 'STEEMUSDT'] else 'Shan'\n                        self._save_position(current_symbol, current_side, current_data, user)\n                    \n                    current_side = position_match.group(1)\n                    current_symbol = position_match.group(2)\n                    current_data = {'timestamp': datetime.utcnow()}\n                    continue\n                \n                # Parse position details\n                size_match = re.search(self.log_patterns['position_size'], log_line)\n                if size_match:\n                    current_data['size'] = float(size_match.group(1))\n                    continue\n                \n                entry_match = re.search(self.log_patterns['entry_price'], log_line)\n                if entry_match:\n                    current_data['entry_price'] = float(entry_match.group(1))\n                    continue\n                \n                current_match = re.search(self.log_patterns['current_price'], log_line)\n                if current_match:\n                    current_data['current_price'] = float(current_match.group(1))\n                    continue\n                \n                movement_match = re.search(self.log_patterns['price_movement'], log_line)\n                if movement_match:\n                    current_data['price_movement'] = float(movement_match.group(1))\n                    continue\n                \n                # Check for new position marker\n                if re.search(self.log_patterns['new_position'], log_line):\n                    current_data['is_new'] = True\n                    continue\n            \n            # Save the last position\n            if current_symbol and current_data:\n                user = 'Yuva' if current_symbol in ['AVAUSDT', 'STEEMUSDT'] else 'Shan'\n                self._save_position(current_symbol, current_side, current_data, user)\n                \n        except Exception as e:\n            logging.error(f\"Error parsing sample logs: {e}\")\n\n    def _save_position(self, symbol, side, data, user):\n        \"\"\"Save or update position data in database\"\"\"\n        try:\n            # Check if position already exists\n            existing_position = TradingSession.query.filter_by(\n                user=user,\n                symbol=symbol,\n                status='OPEN'\n            ).first()\n            \n            if existing_position:\n                # Update existing position\n                if 'current_price' in data:\n                    existing_position.unrealized_pnl = self._calculate_pnl(\n                        existing_position.entry_price,\n                        data['current_price'],\n                        existing_position.position_size,\n                        existing_position.side\n                    )\n                    existing_position.pnl = existing_position.unrealized_pnl\n                \n                # Update price movement data\n                if 'price_movement' in data:\n                    existing_position.notes = f\"Price Movement: {data['price_movement']}%\"\n                \n                db.session.commit()\n                logging.info(f\"Updated position for {user}: {symbol} {side}\")\n                \n            else:\n                # Create new position\n                position = TradingSession(\n                    user=user,\n                    symbol=symbol,\n                    side=side,\n                    entry_price=data.get('entry_price', 0),\n                    position_size=data.get('size', 0),\n                    status='OPEN',\n                    trade_type='AUTO',\n                    strategy='Binance Futures Bot',\n                    created_at=data.get('timestamp', datetime.utcnow())\n                )\n                \n                # Calculate unrealized PnL if current price available\n                if 'current_price' in data:\n                    position.unrealized_pnl = self._calculate_pnl(\n                        position.entry_price,\n                        data['current_price'],\n                        position.position_size,\n                        position.side\n                    )\n                    position.pnl = position.unrealized_pnl\n                \n                # Add price movement note\n                if 'price_movement' in data:\n                    position.notes = f\"Price Movement: {data['price_movement']}%\"\n                \n                db.session.add(position)\n                db.session.commit()\n                logging.info(f\"Created new position for {user}: {symbol} {side} at {position.entry_price}\")\n                \n        except Exception as e:\n            logging.error(f\"Error saving position: {e}\")\n            db.session.rollback()\n\n    def _calculate_pnl(self, entry_price, current_price, size, side):\n        \"\"\"Calculate PnL for a position\"\"\"\n        try:\n            if side == 'LONG':\n                return (current_price - entry_price) * size\n            else:  # SHORT\n                return (entry_price - current_price) * size\n        except:\n            return 0.0\n\n    def close_position(self, user, symbol, exit_price):\n        \"\"\"Close a position and calculate realized PnL\"\"\"\n        try:\n            position = TradingSession.query.filter_by(\n                user=user,\n                symbol=symbol,\n                status='OPEN'\n            ).first()\n            \n            if position:\n                position.exit_price = exit_price\n                position.closed_at = datetime.utcnow()\n                position.status = 'CLOSED'\n                position.realized_pnl = self._calculate_pnl(\n                    position.entry_price,\n                    exit_price,\n                    position.position_size,\n                    position.side\n                )\n                position.pnl = position.realized_pnl\n                \n                db.session.commit()\n                logging.info(f\"Closed position for {user}: {symbol} with PnL: {position.realized_pnl}\")\n                return True\n                \n        except Exception as e:\n            logging.error(f\"Error closing position: {e}\")\n            db.session.rollback()\n        \n        return False\n\n    def get_recent_logs(self, limit=50):\n        \"\"\"Get recent log entries formatted for display\"\"\"\n        try:\n            # Get recent trading sessions for log display\n            sessions = TradingSession.query.order_by(\n                TradingSession.created_at.desc()\n            ).limit(limit).all()\n            \n            logs = []\n            for session in sessions:\n                log_entry = {\n                    'timestamp': session.created_at.strftime('%Y-%m-%d %H:%M:%S') if session.created_at else 'N/A',\n                    'level': 'INFO',\n                    'message': f\"{session.side} position for {session.symbol}: Entry=${session.entry_price:.4f}, Size={session.position_size}, PnL=${session.pnl:.2f}\",\n                    'source': f\"{session.user.lower()}_trading_bot\",\n                    'user': session.user,\n                    'symbol': session.symbol,\n                    'status': session.status\n                }\n                logs.append(log_entry)\n            \n            return logs\n            \n        except Exception as e:\n            logging.error(f\"Error getting recent logs: {e}\")\n            return []","size_bytes":14175},"services/historical_analytics.py":{"content":"\"\"\"\nHistorical Analytics Service\nComprehensive trade history analysis with period-based comparisons\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta, date\nfrom sqlalchemy import func, and_, or_\nfrom app import db\nfrom models import TradingSession, TradingStats\n\nclass HistoricalAnalytics:\n    \"\"\"Service for comprehensive historical trading analysis\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n    \n    def get_period_comparison(self, period='today'):\n        \"\"\"\n        Get Long vs Short comparison for specified period\n        Periods: today, yesterday, week, month, year, all\n        \"\"\"\n        end_date = datetime.utcnow().date()\n        \n        if period == 'today':\n            start_date = end_date\n        elif period == 'yesterday':\n            start_date = end_date - timedelta(days=1)\n            end_date = start_date\n        elif period == 'week':\n            start_date = end_date - timedelta(days=7)\n        elif period == 'month':\n            start_date = end_date - timedelta(days=30)\n        elif period == 'year':\n            start_date = end_date - timedelta(days=365)\n        else:  # all time\n            start_date = date(2020, 1, 1)  # Far back start date\n            \n        return self._get_period_stats(start_date, end_date)\n    \n    def _get_period_stats(self, start_date, end_date):\n        \"\"\"Get comprehensive stats for date range\"\"\"\n        try:\n            # Query for positions in date range\n            query = TradingSession.query.filter(\n                func.date(TradingSession.created_at) >= start_date,\n                func.date(TradingSession.created_at) <= end_date\n            )\n            \n            # Overall stats\n            total_positions = query.count()\n            \n            # Long position stats\n            long_query = query.filter(TradingSession.side == 'LONG')\n            long_positions = long_query.count()\n            long_profitable = long_query.filter(TradingSession.pnl > 0).count()\n            long_total_pnl = long_query.with_entities(func.sum(TradingSession.pnl)).scalar() or 0\n            \n            # Short position stats\n            short_query = query.filter(TradingSession.side == 'SHORT')\n            short_positions = short_query.count()\n            short_profitable = short_query.filter(TradingSession.pnl > 0).count()\n            short_total_pnl = short_query.with_entities(func.sum(TradingSession.pnl)).scalar() or 0\n            \n            # Calculate success rates\n            long_success_rate = (long_profitable / long_positions * 100) if long_positions > 0 else 0\n            short_success_rate = (short_profitable / short_positions * 100) if short_positions > 0 else 0\n            overall_success_rate = ((long_profitable + short_profitable) / total_positions * 100) if total_positions > 0 else 0\n            \n            return {\n                'period': f\"{start_date} to {end_date}\",\n                'total_positions': total_positions,\n                'long': {\n                    'positions': long_positions,\n                    'profitable': long_profitable,\n                    'success_rate': round(long_success_rate, 1),\n                    'total_pnl': round(long_total_pnl, 2),\n                    'avg_pnl': round(long_total_pnl / long_positions, 2) if long_positions > 0 else 0\n                },\n                'short': {\n                    'positions': short_positions,\n                    'profitable': short_profitable,\n                    'success_rate': round(short_success_rate, 1),\n                    'total_pnl': round(short_total_pnl, 2),\n                    'avg_pnl': round(short_total_pnl / short_positions, 2) if short_positions > 0 else 0\n                },\n                'overall': {\n                    'success_rate': round(overall_success_rate, 1),\n                    'total_pnl': round(long_total_pnl + short_total_pnl, 2),\n                    'best_side': 'LONG' if long_success_rate > short_success_rate else 'SHORT'\n                }\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating period stats: {e}\")\n            return self._empty_stats()\n    \n    def get_weekly_comparison(self, weeks_back=4):\n        \"\"\"Get Long vs Short comparison for last N weeks\"\"\"\n        weekly_data = []\n        today = datetime.utcnow().date()\n        \n        for i in range(weeks_back):\n            week_end = today - timedelta(days=i*7)\n            week_start = week_end - timedelta(days=6)\n            \n            stats = self._get_period_stats(week_start, week_end)\n            stats['week_label'] = f\"Week {i+1}\"\n            stats['week_start'] = week_start\n            stats['week_end'] = week_end\n            weekly_data.append(stats)\n            \n        return weekly_data\n    \n    def get_monthly_comparison(self, months_back=6):\n        \"\"\"Get Long vs Short comparison for last N months\"\"\"\n        monthly_data = []\n        today = datetime.utcnow().date()\n        \n        for i in range(months_back):\n            # Calculate month boundaries\n            if i == 0:\n                month_end = today\n                month_start = date(today.year, today.month, 1)\n            else:\n                temp_date = today.replace(day=1) - timedelta(days=i*30)\n                month_start = date(temp_date.year, temp_date.month, 1)\n                # Get last day of month\n                if temp_date.month == 12:\n                    month_end = date(temp_date.year + 1, 1, 1) - timedelta(days=1)\n                else:\n                    month_end = date(temp_date.year, temp_date.month + 1, 1) - timedelta(days=1)\n            \n            stats = self._get_period_stats(month_start, month_end)\n            stats['month_label'] = month_start.strftime('%B %Y')\n            stats['month_start'] = month_start\n            stats['month_end'] = month_end\n            monthly_data.append(stats)\n            \n        return monthly_data\n    \n    def get_performance_summary(self):\n        \"\"\"Get overall performance summary with key metrics\"\"\"\n        try:\n            # Get all-time stats\n            all_time = self.get_period_comparison('all')\n            \n            # Get recent performance\n            today_stats = self.get_period_comparison('today')\n            week_stats = self.get_period_comparison('week')\n            month_stats = self.get_period_comparison('month')\n            \n            # Best performing period\n            periods = [\n                ('Today', today_stats['overall']['success_rate']),\n                ('This Week', week_stats['overall']['success_rate']),\n                ('This Month', month_stats['overall']['success_rate']),\n                ('All Time', all_time['overall']['success_rate'])\n            ]\n            \n            best_period = max(periods, key=lambda x: x[1])\n            \n            return {\n                'all_time': all_time,\n                'recent': {\n                    'today': today_stats,\n                    'week': week_stats,\n                    'month': month_stats\n                },\n                'best_period': {\n                    'name': best_period[0],\n                    'success_rate': best_period[1]\n                },\n                'recommendations': self._generate_recommendations(all_time, week_stats)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating performance summary: {e}\")\n            return {}\n    \n    def _generate_recommendations(self, all_time, week_stats):\n        \"\"\"Generate trading recommendations based on historical data\"\"\"\n        recommendations = []\n        \n        # Compare Long vs Short performance\n        long_rate = all_time['long']['success_rate']\n        short_rate = all_time['short']['success_rate']\n        \n        if long_rate > short_rate + 10:\n            recommendations.append({\n                'type': 'strategy',\n                'message': f\"Focus on LONG positions - {long_rate:.1f}% success rate vs {short_rate:.1f}% for SHORT\"\n            })\n        elif short_rate > long_rate + 10:\n            recommendations.append({\n                'type': 'strategy', \n                'message': f\"Focus on SHORT positions - {short_rate:.1f}% success rate vs {long_rate:.1f}% for LONG\"\n            })\n        \n        # Recent trend analysis\n        week_long = week_stats['long']['success_rate']\n        week_short = week_stats['short']['success_rate']\n        \n        if week_long > long_rate + 5:\n            recommendations.append({\n                'type': 'trend',\n                'message': f\"LONG positions trending up - {week_long:.1f}% this week vs {long_rate:.1f}% average\"\n            })\n        \n        if week_short > short_rate + 5:\n            recommendations.append({\n                'type': 'trend',\n                'message': f\"SHORT positions trending up - {week_short:.1f}% this week vs {short_rate:.1f}% average\"\n            })\n        \n        return recommendations\n    \n    def save_daily_stats(self, date_to_save=None):\n        \"\"\"Save or update daily statistics for historical tracking\"\"\"\n        if date_to_save is None:\n            date_to_save = datetime.utcnow().date()\n            \n        try:\n            # Get stats for the day\n            stats = self._get_period_stats(date_to_save, date_to_save)\n            \n            # Save stats for both users (combined for Long vs Short focus)\n            for user in ['Yuva', 'Shan']:\n                # Check if stats already exist\n                existing = TradingStats.query.filter_by(\n                    user=user,\n                    period='daily',\n                    period_date=datetime.combine(date_to_save, datetime.min.time())\n                ).first()\n                \n                if existing:\n                    # Update existing record\n                    self._update_stats_record(existing, stats, user)\n                else:\n                    # Create new record\n                    new_stats = TradingStats(\n                        user=user,\n                        period='daily',\n                        period_date=datetime.combine(date_to_save, datetime.min.time())\n                    )\n                    self._update_stats_record(new_stats, stats, user)\n                    db.session.add(new_stats)\n            \n            db.session.commit()\n            self.logger.info(f\"Daily stats saved for {date_to_save}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error saving daily stats: {e}\")\n            db.session.rollback()\n    \n    def _update_stats_record(self, record, stats, user):\n        \"\"\"Update a TradingStats record with calculated stats\"\"\"\n        # For simplicity, split stats between users\n        user_multiplier = 0.6 if user == 'Yuva' else 0.4  # Yuva gets 60%, Shan gets 40%\n        \n        record.long_trades = int(stats['long']['positions'] * user_multiplier)\n        record.long_successful = int(stats['long']['profitable'] * user_multiplier) \n        record.short_trades = int(stats['short']['positions'] * user_multiplier)\n        record.short_successful = int(stats['short']['profitable'] * user_multiplier)\n        record.total_trades = record.long_trades + record.short_trades\n        record.successful_trades = record.long_successful + record.short_successful\n        record.total_pnl = stats['overall']['total_pnl'] * user_multiplier\n        record.win_rate = stats['overall']['success_rate']\n        record.last_updated = datetime.utcnow()\n    \n    def _empty_stats(self):\n        \"\"\"Return empty stats structure\"\"\"\n        return {\n            'period': 'No data',\n            'total_positions': 0,\n            'long': {\n                'positions': 0,\n                'profitable': 0,\n                'success_rate': 0,\n                'total_pnl': 0,\n                'avg_pnl': 0\n            },\n            'short': {\n                'positions': 0,\n                'profitable': 0,\n                'success_rate': 0,\n                'total_pnl': 0,\n                'avg_pnl': 0\n            },\n            'overall': {\n                'success_rate': 0,\n                'total_pnl': 0,\n                'best_side': 'LONG'\n            }\n        }\n\n# Global instance\nhistorical_analytics = HistoricalAnalytics()","size_bytes":12295},"services/log_parser.py":{"content":"import re\nimport logging\nfrom datetime import datetime\nfrom app import db\nfrom models import TradingSession\n\nclass LogParser:\n    def __init__(self):\n        self.log_patterns = {\n            'position_entry': r'📈 Managing (LONG|SHORT) position for ([A-Z]+USDT):',\n            'position_size': r'Position Size: ([\\d.]+)',\n            'entry_price': r'Entry Price: ([\\d.]+)',\n            'current_price': r'Current Price: ([\\d.]+)',\n            'price_movement': r'Price Movement: ([\\d.-]+)%',\n            'success_count': r'(BUY|SELL) Success Count: (\\d+)',\n            'stop_loss_count': r'(BUY|SELL) Stop Loss Count: (\\d+)',\n            'live_trade_success': r'Live Trade Success Count: (\\d+)',\n            'live_trade_failure': r'Live Trade Failure Count: (\\d+)',\n            'container_status': r'(BUY|SELL) Container Running: (True|False)'\n        }\n\n    def parse_latest_logs(self):\n        \"\"\"Parse latest logs from containers\"\"\"\n        try:\n            # In a real implementation, you would read from the log files\n            # For now, we'll simulate parsing the provided log data\n            self._parse_sample_logs()\n        except Exception as e:\n            logging.error(f\"Error parsing logs: {e}\")\n\n    def _parse_sample_logs(self):\n        \"\"\"Parse the sample log data provided including AVAUSDT data\"\"\"\n        sample_logs = [\n            \"📈 Managing LONG position for AVAUSDT:\",\n            \"Position Size: 268.5\",\n            \"Entry Price: 0.5615128119181\",\n            \"Current Price: 0.5573000\",\n            \"📈 Managing LONG position for CHRUSDT:\",\n            \"Position Size: 1755\",\n            \"Entry Price: 0.0901\",\n            \"Current Price: 0.0890\",\n            \"📈 Managing LONG position for GHSTUSDT:\",\n            \"Position Size: 365\", \n            \"Entry Price: 0.4330567123287\",\n            \"Current Price: 0.4308000\"\n        ]\n        \n        try:\n            current_symbol = None\n            current_side = None\n            current_data = {}\n            \n            for log_line in sample_logs:\n                # Check for position entry\n                position_match = re.search(self.log_patterns['position_entry'], log_line)\n                if position_match:\n                    if current_symbol and current_data:\n                        self._save_position(current_symbol, current_side, current_data, 'Yuva')\n                    \n                    current_side = position_match.group(1)\n                    current_symbol = position_match.group(2)\n                    current_data = {}\n                    continue\n                \n                # Parse position details\n                size_match = re.search(self.log_patterns['position_size'], log_line)\n                if size_match:\n                    current_data['size'] = float(size_match.group(1))\n                    continue\n                \n                entry_match = re.search(self.log_patterns['entry_price'], log_line)\n                if entry_match:\n                    current_data['entry_price'] = float(entry_match.group(1))\n                    continue\n                \n                current_match = re.search(self.log_patterns['current_price'], log_line)\n                if current_match:\n                    current_data['current_price'] = float(current_match.group(1))\n                    continue\n            \n            # Save the last position\n            if current_symbol and current_data:\n                self._save_position(current_symbol, current_side, current_data, 'Yuva')\n                \n        except Exception as e:\n            logging.error(f\"Error parsing sample logs: {e}\")\n\n    def _save_position(self, symbol, side, data, user):\n        \"\"\"Save position data to database\"\"\"\n        try:\n            # Check if position already exists\n            existing_position = TradingSession.query.filter_by(\n                user=user,\n                symbol=symbol,\n                status='OPEN'\n            ).first()\n            \n            if existing_position:\n                # Update existing position\n                if 'current_price' in data:\n                    existing_position.pnl = self._calculate_pnl(\n                        existing_position.entry_price,\n                        data['current_price'],\n                        existing_position.position_size,\n                        existing_position.side\n                    )\n                db.session.commit()\n            else:\n                # Create new position\n                position = TradingSession(\n                    user=user,\n                    symbol=symbol,\n                    side=side,\n                    entry_price=data.get('entry_price', 0),\n                    position_size=data.get('size', 0),\n                    status='OPEN'\n                )\n                \n                if 'current_price' in data:\n                    position.pnl = self._calculate_pnl(\n                        position.entry_price,\n                        data['current_price'],\n                        position.position_size,\n                        position.side\n                    )\n                \n                db.session.add(position)\n                db.session.commit()\n                \n        except Exception as e:\n            logging.error(f\"Error saving position: {e}\")\n            db.session.rollback()\n\n    def _calculate_pnl(self, entry_price, current_price, size, side):\n        \"\"\"Calculate PnL for a position\"\"\"\n        try:\n            if side == 'LONG':\n                return (current_price - entry_price) * size\n            else:  # SHORT\n                return (entry_price - current_price) * size\n        except:\n            return 0.0\n\n    def get_recent_logs(self, limit=50):\n        \"\"\"Get recent log entries\"\"\"\n        # In a real implementation, this would read from actual log files\n        # For now, return sample log data\n        return [\n            {\n                'timestamp': '2025-08-05 07:19:05',\n                'level': 'INFO',\n                'message': '🔴 Containers detected running - DISABLING API calls',\n                'source': 'strategy_manager'\n            },\n            {\n                'timestamp': '2025-08-05 07:19:43',\n                'level': 'INFO', \n                'message': 'Starting Trading Strategy Manager...',\n                'source': 'strategy_manager'\n            },\n            {\n                'timestamp': '2025-08-05 07:19:44',\n                'level': 'INFO',\n                'message': 'BUY Success Count: 0',\n                'source': 'trading_bot'\n            }\n        ]\n","size_bytes":6585},"services/log_reader_service.py":{"content":"import docker\nimport logging\nimport re\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\n\nclass LogReaderService:\n    def __init__(self):\n        try:\n            self.client = docker.from_env()\n        except Exception as e:\n            logging.error(f\"Failed to connect to Docker: {e}\")\n            self.client = None\n    \n    def get_log_reader_logs(self, lines: int = 100) -> List[Dict]:\n        \"\"\"\n        Get logs from the log-reader container and parse them into structured data\n        \"\"\"\n        if not self.client:\n            return []\n        \n        try:\n            container = self.client.containers.get('log-reader')\n            if container.status != 'running':\n                return []\n            \n            # Get recent logs\n            logs = container.logs(tail=lines, timestamps=True).decode('utf-8')\n            return self._parse_strategy_logs(logs)\n            \n        except Exception as e:\n            logging.error(f\"Error reading log-reader container logs: {e}\")\n            return []\n    \n    def _parse_strategy_logs(self, logs: str) -> List[Dict]:\n        \"\"\"\n        Parse the strategy manager logs into structured data\n        \"\"\"\n        parsed_logs = []\n        lines = logs.strip().split('\\n')\n        \n        current_status = {}\n        \n        for line in lines:\n            if not line.strip():\n                continue\n            \n            try:\n                # Extract timestamp and message\n                timestamp_match = re.match(r'^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z)\\s+(.+)$', line)\n                if timestamp_match:\n                    timestamp_str = timestamp_match.group(1)\n                    message = timestamp_match.group(2)\n                else:\n                    # Fallback for logs without Docker timestamp\n                    message = line\n                    timestamp_str = datetime.utcnow().isoformat() + 'Z'\n                \n                # Parse different log types\n                log_entry = self._parse_log_message(message, timestamp_str)\n                if log_entry:\n                    parsed_logs.append(log_entry)\n                    \n                    # Update current status if it's a status entry\n                    if log_entry['type'] == 'status_update':\n                        current_status.update(log_entry.get('data', {}))\n                        \n            except Exception as e:\n                logging.error(f\"Error parsing log line: {line}, error: {e}\")\n                continue\n        \n        # Add current status as the latest entry if we have it\n        if current_status:\n            parsed_logs.append({\n                'timestamp': datetime.utcnow().isoformat() + 'Z',\n                'type': 'current_status',\n                'message': 'Current Trading Status',\n                'data': current_status,\n                'level': 'info'\n            })\n        \n        return sorted(parsed_logs, key=lambda x: x['timestamp'], reverse=True)\n    \n    def _parse_log_message(self, message: str, timestamp: str) -> Optional[Dict]:\n        \"\"\"\n        Parse individual log messages into structured format\n        \"\"\"\n        log_entry = {\n            'timestamp': timestamp,\n            'raw_message': message,\n            'level': 'info'\n        }\n        \n        # Remove timestamp prefix if present in message\n        message = re.sub(r'^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2} - ', '', message)\n        \n        # Parse different message types\n        if '🔴 Containers detected running - DISABLING API calls' in message:\n            log_entry.update({\n                'type': 'system_alert',\n                'message': 'Containers detected - API calls disabled',\n                'level': 'warning',\n                'icon': 'exclamation-triangle'\n            })\n            \n        elif 'Starting Trading Strategy Manager' in message:\n            log_entry.update({\n                'type': 'system_start',\n                'message': 'Trading Strategy Manager started',\n                'level': 'success',\n                'icon': 'play-circle'\n            })\n            \n        elif '🔄 LIVE TRADING DETECTED' in message:\n            log_entry.update({\n                'type': 'trading_mode',\n                'message': 'Live trading mode activated',\n                'level': 'info',\n                'icon': 'broadcast-pin'\n            })\n            \n        elif '🚀 Live trading detected' in message:\n            log_entry.update({\n                'type': 'monitoring_start',\n                'message': 'Live trading monitoring started',\n                'level': 'success',\n                'icon': 'rocket'\n            })\n            \n        elif '=== Current Status ===' in message:\n            log_entry.update({\n                'type': 'status_header',\n                'message': 'Status Report',\n                'level': 'info',\n                'icon': 'info-circle'\n            })\n            \n        elif self._is_status_line(message):\n            status_data = self._parse_status_line(message)\n            if status_data:\n                log_entry.update({\n                    'type': 'status_update',\n                    'message': f\"{status_data['key']}: {status_data['value']}\",\n                    'data': {status_data['key']: status_data['value']},\n                    'level': 'info',\n                    'icon': 'info'\n                })\n                \n        else:\n            log_entry.update({\n                'type': 'general',\n                'message': message,\n                'level': 'info',\n                'icon': 'info'\n            })\n        \n        return log_entry\n    \n    def _is_status_line(self, message: str) -> bool:\n        \"\"\"Check if the message is a status line\"\"\"\n        status_patterns = [\n            r'BUY Coins Tracking:',\n            r'SELL Coins Tracking:',\n            r'BUY Success Count:',\n            r'BUY Stop Loss Count:',\n            r'SELL Success Count:',\n            r'SELL Stop Loss Count:',\n            r'Live Trade Success Count:',\n            r'Live Trade Failure Count:',\n            r'BUY Container Running:',\n            r'SELL Container Running:',\n            r'Waiting for BUY start:',\n            r'Waiting for SELL start:',\n            r'API Calls Enabled:',\n            r'Weekly Reset In Progress:',\n            r'Current IST Time:',\n            r'Next Weekly Reset:'\n        ]\n        \n        return any(re.search(pattern, message) for pattern in status_patterns)\n    \n    def _parse_status_line(self, message: str) -> Optional[Dict]:\n        \"\"\"Parse status line into key-value pair\"\"\"\n        match = re.match(r'^(.+?):\\s*(.+)$', message)\n        if match:\n            key = match.group(1).strip()\n            value = match.group(2).strip()\n            return {'key': key, 'value': value}\n        return None\n    \n    def get_trading_summary(self) -> Dict:\n        \"\"\"\n        Get a summary of current trading status from logs\n        \"\"\"\n        logs = self.get_log_reader_logs(lines=50)\n        \n        summary = {\n            'status': 'unknown',\n            'api_enabled': False,\n            'buy_container_running': False,\n            'sell_container_running': False,\n            'live_trades_success': 0,\n            'live_trades_failure': 0,\n            'last_update': None\n        }\n        \n        # Extract latest status information\n        for log in logs:\n            if log.get('type') == 'status_update' and log.get('data'):\n                data = log['data']\n                key = list(data.keys())[0] if data else None\n                value = list(data.values())[0] if data else None\n                \n                if key == 'API Calls Enabled':\n                    summary['api_enabled'] = value.lower() == 'true'\n                elif key == 'BUY Container Running':\n                    summary['buy_container_running'] = value.lower() == 'true'\n                elif key == 'SELL Container Running':\n                    summary['sell_container_running'] = value.lower() == 'true'\n                elif key == 'Live Trade Success Count':\n                    try:\n                        summary['live_trades_success'] = int(value)\n                    except ValueError:\n                        pass\n                elif key == 'Live Trade Failure Count':\n                    try:\n                        summary['live_trades_failure'] = int(value)\n                    except ValueError:\n                        pass\n                elif key == 'Current IST Time':\n                    summary['last_update'] = value\n        \n        # Determine overall status\n        if summary['buy_container_running'] or summary['sell_container_running']:\n            summary['status'] = 'active'\n        else:\n            summary['status'] = 'inactive'\n            \n        return summary","size_bytes":8829},"services/trading_analytics.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func\nfrom app import db\nfrom models import TradingSession, TradingStats\n\nclass TradingAnalytics:\n    def __init__(self):\n        pass\n\n    def get_user_stats(self, user):\n        \"\"\"Get comprehensive trading statistics for a user\"\"\"\n        try:\n            # Get all trading sessions for user\n            sessions = TradingSession.query.filter_by(user=user).all()\n            \n            stats = {\n                'total_trades': len(sessions),\n                'successful_trades': len([s for s in sessions if s.status == 'CLOSED' and s.pnl > 0]),\n                'failed_trades': len([s for s in sessions if s.status == 'CLOSED' and s.pnl <= 0]),\n                'long_trades': len([s for s in sessions if s.side == 'LONG']),\n                'short_trades': len([s for s in sessions if s.side == 'SHORT']),\n                'total_pnl': sum([s.pnl for s in sessions if s.pnl]),\n                'open_positions': len([s for s in sessions if s.status == 'OPEN']),\n                'win_rate': 0.0,\n                'avg_profit': 0.0,\n                'avg_loss': 0.0,\n                'profit_factor': 0.0\n            }\n            \n            # Calculate win rate\n            closed_trades = [s for s in sessions if s.status == 'CLOSED']\n            if closed_trades:\n                winning_trades = [s for s in closed_trades if s.pnl > 0]\n                stats['win_rate'] = (len(winning_trades) / len(closed_trades)) * 100\n                \n                # Calculate average profit/loss\n                profits = [s.pnl for s in closed_trades if s.pnl > 0]\n                losses = [abs(s.pnl) for s in closed_trades if s.pnl < 0]\n                \n                if profits:\n                    stats['avg_profit'] = sum(profits) / len(profits)\n                if losses:\n                    stats['avg_loss'] = sum(losses) / len(losses)\n                \n                # Calculate profit factor\n                total_profits = sum(profits) if profits else 0\n                total_losses = sum(losses) if losses else 0\n                if total_losses > 0:\n                    stats['profit_factor'] = total_profits / total_losses\n            \n            return stats\n            \n        except Exception as e:\n            logging.error(f\"Error getting user stats for {user}: {e}\")\n            return {\n                'total_trades': 0,\n                'successful_trades': 0,\n                'failed_trades': 0,\n                'long_trades': 0,\n                'short_trades': 0,\n                'total_pnl': 0.0,\n                'open_positions': 0,\n                'win_rate': 0.0,\n                'avg_profit': 0.0,\n                'avg_loss': 0.0,\n                'profit_factor': 0.0\n            }\n\n    def get_current_positions(self):\n        \"\"\"Get all current open positions\"\"\"\n        try:\n            positions = TradingSession.query.filter_by(status='OPEN').all()\n            return [\n                {\n                    'user': pos.user,\n                    'symbol': pos.symbol,\n                    'side': pos.side,\n                    'entry_price': pos.entry_price,\n                    'position_size': pos.position_size,\n                    'pnl': pos.pnl or 0.0,\n                    'created_at': pos.created_at.strftime('%Y-%m-%d %H:%M:%S') if pos.created_at else 'N/A'\n                }\n                for pos in positions\n            ]\n        except Exception as e:\n            logging.error(f\"Error getting current positions: {e}\")\n            return []\n\n    def update_statistics(self):\n        \"\"\"Update trading statistics in database\"\"\"\n        try:\n            from datetime import datetime\n            for user in ['Yuva', 'Shan']:\n                stats = self.get_user_stats(user)\n                \n                # Update or create stats record for 'all_time' period\n                db_stats = TradingStats.query.filter_by(\n                    user=user, \n                    period='all_time'\n                ).first()\n                \n                if db_stats:\n                    db_stats.total_trades = stats['total_trades']\n                    db_stats.successful_trades = stats['successful_trades']\n                    db_stats.failed_trades = stats['failed_trades']\n                    db_stats.long_trades = stats['long_trades']\n                    db_stats.short_trades = stats['short_trades']\n                    db_stats.total_pnl = stats['total_pnl']\n                    db_stats.win_rate = stats['win_rate']\n                    db_stats.last_updated = datetime.utcnow()\n                else:\n                    db_stats = TradingStats(\n                        user=user,\n                        period='all_time',\n                        period_date=datetime(2020, 1, 1),  # Fixed start date for all-time stats\n                        total_trades=stats['total_trades'],\n                        successful_trades=stats['successful_trades'],\n                        failed_trades=stats['failed_trades'],\n                        long_trades=stats['long_trades'],\n                        short_trades=stats['short_trades'],\n                        total_pnl=stats['total_pnl'],\n                        win_rate=stats['win_rate'],\n                        avg_win=stats.get('avg_profit', 0.0),\n                        avg_loss=stats.get('avg_loss', 0.0),\n                        profit_factor=stats.get('profit_factor', 0.0)\n                    )\n                    db.session.add(db_stats)\n            \n            db.session.commit()\n            \n        except Exception as e:\n            logging.error(f\"Error updating statistics: {e}\")\n            db.session.rollback()\n\n    def get_daily_pnl_chart_data(self, user, days=30):\n        \"\"\"Get daily PnL data for charts\"\"\"\n        try:\n            end_date = datetime.utcnow()\n            start_date = end_date - timedelta(days=days)\n            \n            # Query closed positions within date range\n            sessions = TradingSession.query.filter(\n                TradingSession.user == user,\n                TradingSession.status == 'CLOSED',\n                TradingSession.closed_at >= start_date,\n                TradingSession.closed_at <= end_date\n            ).order_by(TradingSession.closed_at).all()\n            \n            # Group by date and sum PnL\n            daily_pnl = {}\n            for session in sessions:\n                date_key = session.closed_at.strftime('%Y-%m-%d')\n                if date_key not in daily_pnl:\n                    daily_pnl[date_key] = 0\n                daily_pnl[date_key] += session.pnl or 0\n            \n            # Fill missing dates with 0\n            current_date = start_date\n            chart_data = []\n            while current_date <= end_date:\n                date_key = current_date.strftime('%Y-%m-%d')\n                chart_data.append({\n                    'date': date_key,\n                    'pnl': daily_pnl.get(date_key, 0)\n                })\n                current_date += timedelta(days=1)\n            \n            return chart_data\n            \n        except Exception as e:\n            logging.error(f\"Error getting daily PnL data: {e}\")\n            return []\n    \n    def get_trade_history_by_period(self, period):\n        \"\"\"Get trade history filtered by time period\"\"\"\n        try:\n            from datetime import datetime, timedelta\n            \n            now = datetime.utcnow()\n            if period == 'today':\n                start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)\n            elif period == 'week':\n                start_date = now - timedelta(days=7)\n            elif period == 'month':\n                start_date = now - timedelta(days=30)\n            elif period == 'year':\n                start_date = now - timedelta(days=365)\n            else:  # 'all'\n                start_date = datetime(2020, 1, 1)  # Far back date\n            \n            trades = TradingSession.query.filter(\n                TradingSession.created_at >= start_date\n            ).order_by(TradingSession.created_at.desc()).all()\n            \n            return [\n                {\n                    'id': trade.id,\n                    'user': trade.user,\n                    'symbol': trade.symbol,\n                    'side': trade.side,\n                    'entry_price': trade.entry_price,\n                    'exit_price': trade.exit_price,\n                    'position_size': trade.position_size,\n                    'pnl': trade.pnl or 0.0,\n                    'status': trade.status,\n                    'created_at': trade.created_at.isoformat() if trade.created_at else None,\n                    'closed_at': trade.closed_at.isoformat() if trade.closed_at else None\n                }\n                for trade in trades\n            ]\n            \n        except Exception as e:\n            logging.error(f\"Error getting trade history by period: {e}\")\n            return []\n    \n    def get_user_stats_by_period(self, user, period):\n        \"\"\"Get user statistics for a specific time period\"\"\"\n        try:\n            from datetime import datetime, timedelta\n            \n            now = datetime.utcnow()\n            if period == 'today':\n                start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)\n            elif period == 'week':\n                start_date = now - timedelta(days=7)\n            elif period == 'month':\n                start_date = now - timedelta(days=30)\n            elif period == 'year':\n                start_date = now - timedelta(days=365)\n            else:  # 'all'\n                start_date = datetime(2020, 1, 1)\n            \n            sessions = TradingSession.query.filter(\n                TradingSession.user == user,\n                TradingSession.created_at >= start_date\n            ).all()\n            \n            stats = {\n                'total_trades': len(sessions),\n                'successful_trades': len([s for s in sessions if s.status == 'CLOSED' and (s.pnl or 0) > 0]),\n                'failed_trades': len([s for s in sessions if s.status == 'CLOSED' and (s.pnl or 0) <= 0]),\n                'long_trades': len([s for s in sessions if s.side == 'LONG']),\n                'short_trades': len([s for s in sessions if s.side == 'SHORT']),\n                'long_successful': len([s for s in sessions if s.side == 'LONG' and s.status == 'CLOSED' and (s.pnl or 0) > 0]),\n                'long_failed': len([s for s in sessions if s.side == 'LONG' and s.status == 'CLOSED' and (s.pnl or 0) <= 0]),\n                'short_successful': len([s for s in sessions if s.side == 'SHORT' and s.status == 'CLOSED' and (s.pnl or 0) > 0]),\n                'short_failed': len([s for s in sessions if s.side == 'SHORT' and s.status == 'CLOSED' and (s.pnl or 0) <= 0]),\n                'total_pnl': sum([s.pnl or 0 for s in sessions]),\n                'open_positions': len([s for s in sessions if s.status == 'OPEN']),\n                'win_rate': 0.0,\n                'avg_profit': 0.0,\n                'avg_loss': 0.0,\n                'profit_factor': 0.0,\n                'period': period\n            }\n            \n            # Calculate win rate and other metrics\n            closed_trades = [s for s in sessions if s.status == 'CLOSED']\n            if closed_trades:\n                winning_trades = [s for s in closed_trades if (s.pnl or 0) > 0]\n                stats['win_rate'] = (len(winning_trades) / len(closed_trades)) * 100\n                \n                profits = [s.pnl for s in closed_trades if (s.pnl or 0) > 0]\n                losses = [abs(s.pnl) for s in closed_trades if (s.pnl or 0) < 0]\n                \n                if profits:\n                    stats['avg_profit'] = sum(profits) / len(profits)\n                if losses:\n                    stats['avg_loss'] = sum(losses) / len(losses)\n                \n                total_profits = sum(profits) if profits else 0\n                total_losses = sum(losses) if losses else 0\n                if total_losses > 0:\n                    stats['profit_factor'] = total_profits / total_losses\n            \n            return stats\n            \n        except Exception as e:\n            logging.error(f\"Error getting user stats by period: {e}\")\n            return {\n                'total_trades': 0,\n                'successful_trades': 0,\n                'failed_trades': 0,\n                'long_trades': 0,\n                'short_trades': 0,\n                'total_pnl': 0.0,\n                'open_positions': 0,\n                'win_rate': 0.0,\n                'period': period\n            }\n","size_bytes":12631},"static/css/dashboard.css":{"content":"/* Trading Dashboard Custom Styles */\n:root {\n    --primary-color: #007bff;\n    --success-color: #28a745;\n    --danger-color: #dc3545;\n    --warning-color: #ffc107;\n    --info-color: #17a2b8;\n    --dark-color: #343a40;\n    --secondary-color: #6c757d;\n    --light-color: #f8f9fa;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background-color: #1a1d29;\n    color: #ffffff;\n}\n\n/* Card Enhancements */\n.card {\n    border-radius: 12px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;\n}\n\n.card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    padding: 1rem 1.25rem;\n}\n\n.card-body {\n    padding: 1.25rem;\n}\n\n/* Navigation Enhancements */\n.navbar-brand {\n    font-weight: 600;\n    font-size: 1.4rem;\n}\n\n.navbar {\n    backdrop-filter: blur(10px);\n    background-color: rgba(52, 58, 64, 0.95) !important;\n}\n\n/* Stat Cards */\n.card.bg-primary,\n.card.bg-success,\n.card.bg-danger,\n.card.bg-info {\n    background: linear-gradient(135deg, var(--primary-color) 0%, rgba(0, 123, 255, 0.8) 100%);\n}\n\n.card.bg-success {\n    background: linear-gradient(135deg, var(--success-color) 0%, rgba(40, 167, 69, 0.8) 100%);\n}\n\n.card.bg-danger {\n    background: linear-gradient(135deg, var(--danger-color) 0%, rgba(220, 53, 69, 0.8) 100%);\n}\n\n.card.bg-info {\n    background: linear-gradient(135deg, var(--info-color) 0%, rgba(23, 162, 184, 0.8) 100%);\n}\n\n/* Container Status Cards */\n.card.bg-secondary {\n    background-color: #2c3e50 !important;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n/* Badges */\n.badge {\n    font-size: 0.75rem;\n    padding: 0.4em 0.6em;\n    border-radius: 6px;\n}\n\n/* Tables */\n.table-dark {\n    --bs-table-bg: transparent;\n    border-color: rgba(255, 255, 255, 0.1);\n}\n\n.table-dark th,\n.table-dark td {\n    border-color: rgba(255, 255, 255, 0.1);\n    padding: 0.75rem;\n}\n\n.table-striped > tbody > tr:nth-of-type(odd) > td {\n    background-color: rgba(255, 255, 255, 0.05);\n}\n\n/* Progress Bars */\n.progress {\n    height: 8px;\n    border-radius: 4px;\n    background-color: rgba(255, 255, 255, 0.1);\n}\n\n.progress-bar {\n    border-radius: 4px;\n    transition: width 0.3s ease;\n}\n\n/* Buttons */\n.btn {\n    border-radius: 6px;\n    font-weight: 500;\n    transition: all 0.2s ease;\n}\n\n.btn:hover {\n    transform: translateY(-1px);\n}\n\n/* Custom animations */\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.card {\n    animation: fadeInUp 0.5s ease-out;\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n    .card-body {\n        padding: 1rem;\n    }\n    \n    .navbar-brand {\n        font-size: 1.2rem;\n    }\n}\n\n/* Status indicators */\n.status-indicator {\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    display: inline-block;\n    margin-right: 8px;\n}\n\n.status-running {\n    background-color: var(--success-color);\n    box-shadow: 0 0 6px var(--success-color);\n}\n\n.status-stopped {\n    background-color: var(--danger-color);\n    box-shadow: 0 0 6px var(--danger-color);\n}\n\n.status-unknown {\n    background-color: var(--warning-color);\n    box-shadow: 0 0 6px var(--warning-color);\n}\n\n/* Chart container */\ncanvas {\n    max-height: 400px;\n}\n\n/* Loading states */\n.loading {\n    opacity: 0.6;\n    transition: opacity 0.3s ease;\n}\n\n.loading::after {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    margin: -10px 0 0 -10px;\n    border: 2px solid transparent;\n    border-top: 2px solid var(--primary-color);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Text enhancements */\n.text-success {\n    color: #20c997 !important;\n}\n\n.text-danger {\n    color: #fd7e14 !important;\n}\n\n.text-warning {\n    color: #ffc107 !important;\n}\n\n.text-info {\n    color: #0dcaf0 !important;\n}\n\n/* Custom scrollbar */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: rgba(255, 255, 255, 0.1);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: rgba(255, 255, 255, 0.3);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: rgba(255, 255, 255, 0.5);\n}\n","size_bytes":4446},"static/css/enhanced_dashboard.css":{"content":"/* Enhanced Trading Dashboard Styles */\n:root {\n    --primary-color: #4f46e5;\n    --primary-light: #6366f1;\n    --success-color: #10b981;\n    --success-light: #34d399;\n    --danger-color: #ef4444;\n    --danger-light: #f87171;\n    --warning-color: #f59e0b;\n    --warning-light: #fbbf24;\n    --info-color: #06b6d4;\n    --info-light: #22d3ee;\n    --dark-color: #1f2937;\n    --dark-light: #374151;\n    --secondary-color: #6b7280;\n    --light-color: #f9fafb;\n    --border-color: rgba(255, 255, 255, 0.1);\n    --text-muted: #9ca3af;\n    --bg-primary: #0f172a;\n    --bg-secondary: #1e293b;\n    --bg-tertiary: #334155;\n}\n\n* {\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);\n    color: #ffffff;\n    font-size: 14px;\n    line-height: 1.6;\n    min-height: 100vh;\n}\n\n/* Typography */\nh1, h2, h3, h4, h5, h6 {\n    font-weight: 600;\n    line-height: 1.4;\n}\n\n.text-lg {\n    font-size: 1.125rem;\n    font-weight: 600;\n}\n\n.font-weight-bold {\n    font-weight: 700;\n}\n\n.font-monospace {\n    font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;\n}\n\n/* Enhanced Cards */\n.card {\n    background: rgba(30, 41, 59, 0.95);\n    border: 1px solid var(--border-color);\n    border-radius: 16px;\n    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);\n    transition: all 0.3s ease;\n    backdrop-filter: blur(10px);\n}\n\n.card:hover {\n    transform: translateY(-4px);\n    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);\n    border-color: rgba(255, 255, 255, 0.2);\n}\n\n.card-header {\n    background: rgba(15, 23, 42, 0.5);\n    border-bottom: 1px solid var(--border-color);\n    border-radius: 16px 16px 0 0;\n    padding: 1.25rem 1.5rem;\n}\n\n.card-body {\n    padding: 1.5rem;\n}\n\n/* Gradient Cards */\n.bg-gradient-primary {\n    background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-light) 100%);\n    border: none;\n}\n\n.bg-gradient-success {\n    background: linear-gradient(135deg, var(--success-color) 0%, var(--success-light) 100%);\n    border: none;\n}\n\n.bg-gradient-danger {\n    background: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-light) 100%);\n    border: none;\n}\n\n.bg-gradient-info {\n    background: linear-gradient(135deg, var(--info-color) 0%, var(--info-light) 100%);\n    border: none;\n}\n\n/* Navigation */\n.navbar {\n    background: rgba(15, 23, 42, 0.95) !important;\n    backdrop-filter: blur(20px);\n    border-bottom: 1px solid var(--border-color);\n}\n\n.navbar-brand {\n    font-weight: 700;\n    font-size: 1.5rem;\n    color: #ffffff !important;\n}\n\n/* Enhanced Badges */\n.badge {\n    font-size: 0.75rem;\n    font-weight: 600;\n    padding: 0.5rem 0.75rem;\n    border-radius: 8px;\n    letter-spacing: 0.025em;\n    display: inline-flex;\n    align-items: center;\n    gap: 0.25rem;\n}\n\n.badge.fs-6 {\n    font-size: 0.875rem;\n    padding: 0.375rem 0.75rem;\n}\n\n/* Enhanced Tables */\n.table-dark {\n    --bs-table-bg: transparent;\n    --bs-table-color: #ffffff;\n    border-color: var(--border-color);\n}\n\n.table-dark th {\n    background: rgba(15, 23, 42, 0.5);\n    border-color: var(--border-color);\n    font-weight: 600;\n    text-transform: uppercase;\n    font-size: 0.75rem;\n    letter-spacing: 0.05em;\n    padding: 1rem 0.75rem;\n}\n\n.table-dark td {\n    border-color: var(--border-color);\n    padding: 0.875rem 0.75rem;\n    vertical-align: middle;\n}\n\n.table-hover tbody tr:hover {\n    background-color: rgba(255, 255, 255, 0.05);\n}\n\n.table-striped > tbody > tr:nth-of-type(odd) > td {\n    background-color: rgba(255, 255, 255, 0.02);\n}\n\n/* Progress Bars */\n.progress {\n    height: 6px;\n    border-radius: 3px;\n    background: rgba(255, 255, 255, 0.1);\n    overflow: hidden;\n}\n\n.progress-bar {\n    border-radius: 3px;\n    transition: width 0.6s ease;\n}\n\n/* Enhanced Buttons */\n.btn {\n    border-radius: 8px;\n    font-weight: 500;\n    transition: all 0.2s ease;\n    border: none;\n    padding: 0.5rem 1rem;\n    font-size: 0.875rem;\n}\n\n.btn:hover {\n    transform: translateY(-1px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n}\n\n.btn-outline-primary {\n    border: 1px solid var(--primary-color);\n    color: var(--primary-color);\n    background: transparent;\n}\n\n.btn-outline-primary:hover {\n    background: var(--primary-color);\n    color: white;\n}\n\n.btn-outline-primary.active {\n    background: var(--primary-color);\n    color: white;\n    box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);\n}\n\n/* Status Indicators */\n.status-indicator {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    display: inline-block;\n    margin-right: 8px;\n    position: relative;\n}\n\n.status-indicator::before {\n    content: '';\n    position: absolute;\n    top: -2px;\n    left: -2px;\n    right: -2px;\n    bottom: -2px;\n    border-radius: 50%;\n    opacity: 0.3;\n    animation: pulse 2s infinite;\n}\n\n.status-running {\n    background-color: var(--success-color);\n}\n\n.status-running::before {\n    background-color: var(--success-color);\n}\n\n.status-stopped {\n    background-color: var(--danger-color);\n}\n\n.status-stopped::before {\n    background-color: var(--danger-color);\n}\n\n.status-unknown {\n    background-color: var(--warning-color);\n}\n\n.status-unknown::before {\n    background-color: var(--warning-color);\n}\n\n/* Animations */\n@keyframes pulse {\n    0% {\n        transform: scale(1);\n        opacity: 0.3;\n    }\n    50% {\n        transform: scale(1.2);\n        opacity: 0.1;\n    }\n    100% {\n        transform: scale(1);\n        opacity: 0.3;\n    }\n}\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n@keyframes slideInRight {\n    from {\n        opacity: 0;\n        transform: translateX(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\n.card {\n    animation: fadeInUp 0.6s ease-out;\n}\n\n.card:nth-child(even) {\n    animation: slideInRight 0.6s ease-out;\n}\n\n/* Enhanced Color Utilities */\n.text-success {\n    color: var(--success-light) !important;\n}\n\n.text-danger {\n    color: var(--danger-light) !important;\n}\n\n.text-warning {\n    color: var(--warning-light) !important;\n}\n\n.text-info {\n    color: var(--info-light) !important;\n}\n\n.text-primary {\n    color: var(--primary-light) !important;\n}\n\n.text-muted {\n    color: var(--text-muted) !important;\n}\n\n.text-white-75 {\n    color: rgba(255, 255, 255, 0.75) !important;\n}\n\n.text-white-50 {\n    color: rgba(255, 255, 255, 0.5) !important;\n}\n\n/* Background Utilities */\n.bg-opacity-25 {\n    background-color: rgba(var(--bs-bg-opacity-rgb), 0.25) !important;\n}\n\n/* Enhanced Spacing */\n.border-end {\n    border-right: 1px solid var(--border-color) !important;\n}\n\n.border-secondary {\n    border-color: var(--border-color) !important;\n}\n\n/* Charts */\ncanvas {\n    max-height: 400px;\n    border-radius: 8px;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .card-body {\n        padding: 1rem;\n    }\n    \n    .navbar-brand {\n        font-size: 1.25rem;\n    }\n    \n    .table-responsive {\n        font-size: 0.875rem;\n    }\n    \n    .btn {\n        font-size: 0.8rem;\n        padding: 0.4rem 0.8rem;\n    }\n}\n\n@media (max-width: 576px) {\n    .card {\n        border-radius: 12px;\n    }\n    \n    .card-header {\n        padding: 1rem;\n        border-radius: 12px 12px 0 0;\n    }\n    \n    .card-body {\n        padding: 1rem;\n    }\n}\n\n/* Loading States */\n.loading {\n    position: relative;\n    pointer-events: none;\n}\n\n.loading::after {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 24px;\n    height: 24px;\n    margin: -12px 0 0 -12px;\n    border: 2px solid transparent;\n    border-top: 2px solid var(--primary-color);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n    z-index: 1000;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Custom Scrollbar */\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: rgba(255, 255, 255, 0.2);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: rgba(255, 255, 255, 0.3);\n}\n\n/* Feather Icons */\n.feather-lg {\n    opacity: 0.6;\n}\n\n/* Special Effects */\n.card-gradient-border {\n    position: relative;\n    background: linear-gradient(var(--bg-secondary), var(--bg-secondary)) padding-box,\n                linear-gradient(135deg, var(--primary-color), var(--info-color)) border-box;\n    border: 2px solid transparent;\n}","size_bytes":8586},"static/css/phoenix_dashboard.css":{"content":"/* Phoenix Dashboard Styles - Clean Professional Look */\n:root {\n    --phoenix-primary: #2c7be5;\n    --phoenix-success: #28a745;\n    --phoenix-warning: #ffc107;\n    --phoenix-danger: #dc3545;\n    --phoenix-info: #17a2b8;\n    --phoenix-secondary: #6c757d;\n    --phoenix-light: #f8f9fa;\n    --phoenix-dark: #343a40;\n    --phoenix-body-bg: #f7f8fc;\n    --phoenix-body-color: #5e6e82;\n    --phoenix-card-bg: #ffffff;\n    --phoenix-border-color: rgba(0, 0, 0, 0.08);\n    --phoenix-text-primary: #1e2329;\n    --phoenix-text-secondary: #9da4ae;\n}\n\n/* Global Styles */\nbody {\n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    background-color: var(--phoenix-body-bg);\n    color: var(--phoenix-body-color);\n    font-size: 14px;\n    line-height: 1.5;\n}\n\n.container-fluid {\n    max-width: 1400px;\n}\n\n/* Phoenix Card Styles */\n.phoenix-card {\n    background-color: var(--phoenix-card-bg);\n    border: 1px solid var(--phoenix-border-color);\n    border-radius: 12px;\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\n    transition: all 0.2s ease;\n}\n\n.phoenix-card:hover {\n    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);\n    transform: translateY(-1px);\n}\n\n.phoenix-card .card-header {\n    background: transparent;\n    border-bottom: 1px solid var(--phoenix-border-color);\n    padding: 1.25rem 1.5rem 1rem;\n}\n\n.phoenix-card .card-body {\n    padding: 1.25rem 1.5rem;\n}\n\n/* Icon Circles */\n.icon-circle {\n    width: 48px;\n    height: 48px;\n    border-radius: 12px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 20px;\n}\n\n/* Phoenix Buttons */\n.btn-phoenix-secondary {\n    background-color: rgba(108, 117, 125, 0.1);\n    border: 1px solid rgba(108, 117, 125, 0.2);\n    color: #9da9bb;\n    font-size: 12px;\n    font-weight: 500;\n    padding: 0.375rem 0.875rem;\n    border-radius: 6px;\n}\n\n.btn-phoenix-secondary:hover,\n.btn-phoenix-secondary.active {\n    background-color: var(--phoenix-primary);\n    border-color: var(--phoenix-primary);\n    color: white;\n}\n\n/* Phoenix Badges */\n.badge-phoenix {\n    font-weight: 500;\n    padding: 0.375rem 0.75rem;\n    border-radius: 6px;\n    font-size: 11px;\n    letter-spacing: 0.025em;\n}\n\n.badge-phoenix-primary {\n    background-color: rgba(44, 123, 229, 0.1);\n    color: #2c7be5;\n    border: 1px solid rgba(44, 123, 229, 0.2);\n}\n\n.badge-phoenix-success {\n    background-color: rgba(40, 167, 69, 0.1);\n    color: #28a745;\n    border: 1px solid rgba(40, 167, 69, 0.2);\n}\n\n.badge-phoenix-warning {\n    background-color: rgba(255, 193, 7, 0.1);\n    color: #ffc107;\n    border: 1px solid rgba(255, 193, 7, 0.2);\n}\n\n.badge-phoenix-danger {\n    background-color: rgba(220, 53, 69, 0.1);\n    color: #dc3545;\n    border: 1px solid rgba(220, 53, 69, 0.2);\n}\n\n.badge-phoenix-info {\n    background-color: rgba(23, 162, 184, 0.1);\n    color: #17a2b8;\n    border: 1px solid rgba(23, 162, 184, 0.2);\n}\n\n.badge-phoenix-secondary {\n    background-color: rgba(108, 117, 125, 0.1);\n    color: #6c757d;\n    border: 1px solid rgba(108, 117, 125, 0.2);\n}\n\n/* Phoenix Table */\n.phoenix-table {\n    color: var(--phoenix-body-color);\n    margin-bottom: 0;\n}\n\n.phoenix-table th {\n    background: transparent;\n    border-bottom: 1px solid var(--phoenix-border-color);\n    color: #9da9bb;\n    font-weight: 600;\n    font-size: 11px;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n    padding: 0.75rem 0;\n}\n\n.phoenix-table td {\n    border-bottom: 1px solid var(--phoenix-border-color);\n    padding: 0.75rem 0;\n    vertical-align: middle;\n}\n\n.phoenix-table tbody tr:hover {\n    background-color: rgba(255, 255, 255, 0.02);\n}\n\n/* Avatar */\n.avatar {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    width: 32px;\n    height: 32px;\n}\n\n.avatar-xs {\n    width: 24px;\n    height: 24px;\n}\n\n.avatar-name {\n    background-color: var(--phoenix-primary);\n    color: white;\n    font-size: 10px;\n    font-weight: 600;\n    text-transform: uppercase;\n}\n\n/* Bullet Item */\n.bullet-item {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    display: inline-block;\n}\n\n/* Status Indicator */\n.status-indicator {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    display: inline-block;\n    position: relative;\n}\n\n.status-indicator::before {\n    content: '';\n    position: absolute;\n    top: -2px;\n    left: -2px;\n    right: -2px;\n    bottom: -2px;\n    border-radius: 50%;\n    opacity: 0.3;\n    animation: phoenix-pulse 2s infinite;\n}\n\n.status-running {\n    background-color: var(--phoenix-success);\n}\n\n.status-running::before {\n    background-color: var(--phoenix-success);\n}\n\n.status-stopped {\n    background-color: var(--phoenix-danger);\n}\n\n.status-stopped::before {\n    background-color: var(--phoenix-danger);\n}\n\n/* Animations */\n@keyframes phoenix-pulse {\n    0% {\n        transform: scale(1);\n        opacity: 0.3;\n    }\n    50% {\n        transform: scale(1.2);\n        opacity: 0.1;\n    }\n    100% {\n        transform: scale(1);\n        opacity: 0.3;\n    }\n}\n\n/* Typography */\n.fs-7 {\n    font-size: 0.875rem;\n}\n\n.fs-8 {\n    font-size: 0.75rem;\n}\n\n.text-success-emphasis {\n    color: #1e7e34 !important;\n}\n\n.text-warning-emphasis {\n    color: #856404 !important;\n}\n\n.text-info-emphasis {\n    color: #0c5460 !important;\n}\n\n.text-danger-emphasis {\n    color: #721c24 !important;\n}\n\n/* Utility Classes */\n.white-space-nowrap {\n    white-space: nowrap;\n}\n\n.flex-1 {\n    flex: 1;\n}\n\n.btn-reveal-trigger {\n    transition: all 0.2s ease;\n}\n\n.btn-reveal-trigger:hover {\n    background-color: rgba(255, 255, 255, 0.02);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n    .phoenix-card .card-body {\n        padding: 1rem;\n    }\n    \n    .phoenix-card .card-header {\n        padding: 1rem 1rem 0.75rem;\n    }\n    \n    .icon-circle {\n        width: 40px;\n        height: 40px;\n        font-size: 16px;\n    }\n}\n\n/* Custom color emphasis for dark theme */\n.text-success-emphasis {\n    color: #2ea043 !important;\n}\n\n.text-warning-emphasis {\n    color: #d29922 !important;\n}\n\n.text-info-emphasis {\n    color: #0969da !important;\n}\n\n.text-danger-emphasis {\n    color: #cf222e !important;\n}\n\n/* Background utilities for light theme */\n.bg-light-subtle {\n    background-color: rgba(248, 249, 250, 0.8) !important;\n}\n\n/* Light theme navbar */\n.navbar-light .navbar-brand {\n    color: var(--phoenix-text-primary) !important;\n}\n\n.border-bottom {\n    border-color: var(--phoenix-border-color) !important;\n}\n\n/* Better contrast for text */\n.text-white {\n    color: var(--phoenix-text-primary) !important;\n}\n\n.text-muted {\n    color: var(--phoenix-text-secondary) !important;\n}\n\n/* Phoenix Light Theme Overrides */\n.phoenix-card .card-header h5 {\n    color: var(--phoenix-text-primary) !important;\n}\n\n.phoenix-table th {\n    color: var(--phoenix-text-secondary) !important;\n}\n\n.phoenix-table td {\n    color: var(--phoenix-text-primary) !important;\n}\n\n.navbar-dark .navbar-brand {\n    color: var(--phoenix-text-primary) !important;\n}\n\n/* Light theme text colors */\n.text-white-75 {\n    color: var(--phoenix-text-secondary) !important;\n}","size_bytes":7049},"static/js/dashboard.js":{"content":"// Trading Dashboard JavaScript\n\n// Global variables\nlet refreshInterval;\nlet performanceChart;\n\n// Initialize dashboard\ndocument.addEventListener('DOMContentLoaded', function() {\n    updateCurrentTime();\n    setInterval(updateCurrentTime, 1000);\n    \n    // Auto-refresh data every 30 seconds\n    refreshInterval = setInterval(refreshData, 30000);\n    \n    // Initialize tooltips\n    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {\n        return new bootstrap.Tooltip(tooltipTriggerEl);\n    });\n});\n\n// Update current time display\nfunction updateCurrentTime() {\n    const now = new Date();\n    const timeString = now.toLocaleTimeString('en-US', { \n        hour12: false,\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit'\n    });\n    const dateString = now.toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n    });\n    \n    const timeElement = document.getElementById('current-time');\n    if (timeElement) {\n        timeElement.textContent = `${dateString} ${timeString}`;\n    }\n}\n\n// Refresh all dashboard data\nasync function refreshData() {\n    try {\n        showLoadingState();\n        \n        // Call refresh API\n        const response = await fetch('/api/refresh-data');\n        const result = await response.json();\n        \n        if (result.status === 'success') {\n            // Reload the page to update all data\n            setTimeout(() => {\n                window.location.reload();\n            }, 1000);\n            \n            showNotification('Data refreshed successfully', 'success');\n        } else {\n            showNotification('Failed to refresh data: ' + result.message, 'error');\n        }\n    } catch (error) {\n        console.error('Error refreshing data:', error);\n        showNotification('Error refreshing data', 'error');\n    } finally {\n        hideLoadingState();\n    }\n}\n\n// Show loading state\nfunction showLoadingState() {\n    const refreshBtn = document.querySelector('button[onclick=\"refreshData()\"]');\n    if (refreshBtn) {\n        refreshBtn.disabled = true;\n        refreshBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-1\"></i>Refreshing...';\n    }\n    \n    // Add loading class to main cards\n    document.querySelectorAll('.card').forEach(card => {\n        card.classList.add('loading');\n    });\n}\n\n// Hide loading state\nfunction hideLoadingState() {\n    const refreshBtn = document.querySelector('button[onclick=\"refreshData()\"]');\n    if (refreshBtn) {\n        refreshBtn.disabled = false;\n        refreshBtn.innerHTML = '<i class=\"fas fa-sync-alt me-1\"></i>Refresh';\n    }\n    \n    // Remove loading class from cards\n    document.querySelectorAll('.card').forEach(card => {\n        card.classList.remove('loading');\n    });\n}\n\n// Show notification\nfunction showNotification(message, type = 'info') {\n    // Create notification element\n    const notification = document.createElement('div');\n    notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;\n    notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';\n    \n    notification.innerHTML = `\n        ${message}\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n    `;\n    \n    document.body.appendChild(notification);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n        if (notification.parentNode) {\n            notification.remove();\n        }\n    }, 5000);\n}\n\n// Format numbers for display\nfunction formatNumber(num, decimals = 2) {\n    if (num === null || num === undefined) return '0.00';\n    return parseFloat(num).toFixed(decimals);\n}\n\n// Format currency\nfunction formatCurrency(amount, decimals = 2) {\n    if (amount === null || amount === undefined) return '$0.00';\n    return '$' + parseFloat(amount).toFixed(decimals);\n}\n\n// Format percentage\nfunction formatPercentage(value, decimals = 1) {\n    if (value === null || value === undefined) return '0.0%';\n    return parseFloat(value).toFixed(decimals) + '%';\n}\n\n// Update container status with real-time data\nasync function updateContainerStatus() {\n    try {\n        const response = await fetch('/api/container-status');\n        const containers = await response.json();\n        \n        // Update container status cards if they exist\n        containers.forEach(container => {\n            const statusElement = document.querySelector(`[data-container=\"${container.name}\"]`);\n            if (statusElement) {\n                updateContainerCard(statusElement, container);\n            }\n        });\n    } catch (error) {\n        console.error('Error updating container status:', error);\n    }\n}\n\n// Update individual container card\nfunction updateContainerCard(element, containerData) {\n    const statusBadge = element.querySelector('.badge');\n    if (statusBadge) {\n        // Update status badge\n        statusBadge.className = 'badge';\n        if (containerData.status === 'running') {\n            statusBadge.classList.add('bg-success');\n            statusBadge.innerHTML = '<i class=\"fas fa-play me-1\"></i>Running';\n        } else if (containerData.status === 'exited') {\n            statusBadge.classList.add('bg-danger');\n            statusBadge.innerHTML = '<i class=\"fas fa-stop me-1\"></i>Stopped';\n        } else {\n            statusBadge.classList.add('bg-warning');\n            statusBadge.innerHTML = `<i class=\"fas fa-question me-1\"></i>${containerData.status}`;\n        }\n    }\n    \n    // Update uptime\n    const uptimeElement = element.querySelector('.uptime');\n    if (uptimeElement) {\n        uptimeElement.textContent = containerData.uptime || 'N/A';\n    }\n}\n\n// Update trading statistics\nasync function updateTradingStats() {\n    try {\n        const response = await fetch('/api/trading-stats');\n        const stats = await response.json();\n        \n        // Update Yuva stats\n        updateUserStatsCard('yuva', stats.yuva);\n        \n        // Update Shan stats  \n        updateUserStatsCard('shan', stats.shan);\n        \n        // Update overall stats\n        updateOverallStats(stats);\n        \n    } catch (error) {\n        console.error('Error updating trading stats:', error);\n    }\n}\n\n// Update user statistics card\nfunction updateUserStatsCard(user, stats) {\n    const userCard = document.querySelector(`[data-user=\"${user}\"]`);\n    if (!userCard) return;\n    \n    // Update individual stat values\n    const statElements = {\n        'successful-trades': stats.successful_trades || 0,\n        'failed-trades': stats.failed_trades || 0,\n        'long-trades': stats.long_trades || 0,\n        'short-trades': stats.short_trades || 0,\n        'total-pnl': formatCurrency(stats.total_pnl || 0),\n        'win-rate': formatPercentage(stats.win_rate || 0)\n    };\n    \n    Object.entries(statElements).forEach(([key, value]) => {\n        const element = userCard.querySelector(`[data-stat=\"${key}\"]`);\n        if (element) {\n            element.textContent = value;\n        }\n    });\n}\n\n// Update overall dashboard statistics\nfunction updateOverallStats(stats) {\n    const yuvaStats = stats.yuva || {};\n    const shanStats = stats.shan || {};\n    \n    const totalStats = {\n        totalTrades: (yuvaStats.total_trades || 0) + (shanStats.total_trades || 0),\n        successfulTrades: (yuvaStats.successful_trades || 0) + (shanStats.successful_trades || 0),\n        failedTrades: (yuvaStats.failed_trades || 0) + (shanStats.failed_trades || 0),\n        totalPnl: (yuvaStats.total_pnl || 0) + (shanStats.total_pnl || 0)\n    };\n    \n    // Update header stat cards\n    const headerStats = document.querySelectorAll('.card h3');\n    if (headerStats.length >= 4) {\n        headerStats[0].textContent = totalStats.totalTrades;\n        headerStats[1].textContent = totalStats.successfulTrades;\n        headerStats[2].textContent = totalStats.failedTrades;\n        headerStats[3].textContent = formatCurrency(totalStats.totalPnl);\n    }\n}\n\n// Chart utilities\nfunction createPerformanceChart(canvasId, data) {\n    const ctx = document.getElementById(canvasId);\n    if (!ctx) return null;\n    \n    return new Chart(ctx, {\n        type: 'bar',\n        data: data,\n        options: {\n            responsive: true,\n            plugins: {\n                title: {\n                    display: true,\n                    text: 'Trading Performance Comparison',\n                    color: '#ffffff'\n                },\n                legend: {\n                    labels: {\n                        color: '#ffffff'\n                    }\n                }\n            },\n            scales: {\n                y: {\n                    beginAtZero: true,\n                    ticks: {\n                        color: '#ffffff'\n                    },\n                    grid: {\n                        color: 'rgba(255, 255, 255, 0.1)'\n                    }\n                },\n                x: {\n                    ticks: {\n                        color: '#ffffff'\n                    },\n                    grid: {\n                        color: 'rgba(255, 255, 255, 0.1)'\n                    }\n                }\n            }\n        }\n    });\n}\n\n// Utility functions for data processing\nfunction calculateWinRate(successful, total) {\n    if (total === 0) return 0;\n    return (successful / total) * 100;\n}\n\nfunction calculateProfitFactor(profits, losses) {\n    if (losses === 0) return profits > 0 ? Infinity : 0;\n    return profits / losses;\n}\n\n// Real-time updates using Server-Sent Events (if implemented)\nfunction initializeSSE() {\n    if (typeof(EventSource) !== \"undefined\") {\n        const source = new EventSource(\"/api/stream\");\n        \n        source.onmessage = function(event) {\n            const data = JSON.parse(event.data);\n            handleRealtimeUpdate(data);\n        };\n        \n        source.onerror = function(event) {\n            console.error(\"SSE connection error:\", event);\n        };\n    }\n}\n\n// Handle real-time updates\nfunction handleRealtimeUpdate(data) {\n    switch(data.type) {\n        case 'container_status':\n            updateContainerStatus();\n            break;\n        case 'trading_stats':\n            updateTradingStats();\n            break;\n        case 'new_trade':\n            showNotification(`New trade: ${data.symbol} ${data.side}`, 'info');\n            break;\n        default:\n            console.log('Unknown update type:', data.type);\n    }\n}\n\n// Export functions for use in other scripts\nwindow.dashboardUtils = {\n    refreshData,\n    updateContainerStatus,\n    updateTradingStats,\n    formatNumber,\n    formatCurrency,\n    formatPercentage,\n    showNotification\n};\n","size_bytes":10746}}}